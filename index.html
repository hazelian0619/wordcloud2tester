     <!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>è¯äº‘æµ‹è¯•å™¨</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { 
            font-family: 
                -apple-system,           /* ğŸ è‹¹æœç³»ç»Ÿå­—ä½“ - è‹±æ–‡ä¼˜å…ˆ */
                BlinkMacSystemFont,      /* ğŸ Chrome on macOS */
                "PingFang SC",           /* ğŸ è‹¹æœè‹¹æ–¹ - ä¸­æ–‡ä¼˜é›… */
                "SF Pro Display",        /* ğŸ è‹¹æœä¸“ä¸šå­—ä½“ */
                "Helvetica Neue",        /* ğŸ è‹¹æœç»å…¸å­—ä½“ */
                "Source Han Sans CN",    /* ğŸ“š æ€æºé»‘ä½“ - å¼€æºç²¾å“ */
                "Noto Sans CJK SC",      /* ğŸŒ Googleå¼€æºä¸­æ–‡ */
                "Microsoft YaHei",       /* ğŸ’» å¾®è½¯é›…é»‘ - Windowså…¼å®¹ */
                "Hiragino Sans GB",      /* ğŸ“± å†¬é’é»‘ä½“ - æ—¥ç³»ä¼˜é›… */
                "Segoe UI", 
                Roboto, 
                Arial,
                sans-serif; 
            padding: 20px; 
            background: #FFFFFF; /* ğŸ çº¯ç™½èƒŒæ™¯ - è‹¹æœå¼æç®€ */
            color: #1D1D1F; /* ğŸ è‹¹æœæ·±ç°æ–‡å­— */
            margin: 0;
            /* ğŸ”¤ ä¼˜åŒ–å­—ä½“æ¸²æŸ“ */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #FFFFFF; /* ğŸ çº¯ç™½å®¹å™¨ */
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        /* ğŸ ä¸€ä½“åŒ–æ§åˆ¶ç»„ä»¶ - å®Œå…¨å¯¹é½ç»Ÿè®¡ç»„ä»¶ */
        .control-unified {
            background: rgba(248, 249, 250, 0.85);
            border: 1px solid rgba(0, 0, 0, 0.04);
            border-radius: 16px;
            padding: 20px 24px;
            margin-bottom: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04), 0 2px 4px rgba(0, 0, 0, 0.02);
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 32px;
            align-items: center;
        }
        
        /* ğŸ æ“ä½œåŒºåŸŸï¼ˆå³ä¾§åˆ†éš”çº¿æ ·å¼ï¼‰ */
        .action-section {
            display: flex;
            flex-direction: column;
            gap: 14px;
            padding-left: 32px;
            border-left: 1px solid rgba(0, 0, 0, 0.06); /* åˆ†éš”çº¿ */
            min-width: 200px; /* ä¿æŒæœ€å°å®½åº¦ */
        }
        
        /* ğŸ é…ç½®åŒºåŸŸ 2x2 ç½‘æ ¼ */
        .config-section {
            flex: 1;
        }
        
        .config-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 16px 20px; /* å‚ç›´å’Œæ°´å¹³é—´è·ä¸åŒ */
        }
        
        
        .input-group {
            display: flex;
            flex-direction: column;
            min-width: 0; /* å…è®¸å†…å®¹æ”¶ç¼© */
        }
        
        /* ğŸ å®½è¾“å…¥æ¡†æ ·å¼ */
        .input-wide {
            width: 100%;
        }
        
        /* ğŸ æ¬¡è¦æŒ‰é’®ç»„ */
        .secondary-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        /* ğŸƒ è½»ç›ˆæ ‡ç­¾æ ·å¼ */
        .input-group label {
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 6px;
        }
        
        /* ğŸ è‹¹æœé£æ ¼è¾“å…¥æ¡†æ ·å¼ */
        .input-group input, .input-group select {
            width: 100%;
            padding: 8px 14px;
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 12px; /* æ›´åœ†æ¶¦ */
            font-size: 14px;
            background: #ffffff;
            color: #374151;
            height: 36px;
            box-sizing: border-box;
            transition: all 0.2s cubic-bezier(0.4, 0.0, 0.2, 1); /* è‹¹æœåŠ¨ç”»æ›²çº¿ */
            outline: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.03), inset 0 1px 2px rgba(0, 0, 0, 0.02); /* å¾®å¦™å†…é˜´å½± */
        }
        
        /* ğŸ è‹¹æœé£æ ¼ç„¦ç‚¹çŠ¶æ€ */
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.1), 0 2px 6px rgba(0, 0, 0, 0.05);
            transform: translateY(-0.5px); /* å¾®å¦™ä¸Šç§» */
        }
        
        /* ğŸ è‹¹æœé£æ ¼æŒ‰é’®ç»„å®¹å™¨ */
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            justify-self: end;
        }
        
        /* ğŸƒ è½»ç›ˆæŒ‰é’®åŸºç¡€æ ·å¼ */
        .btn {
            padding: 0 16px;
            border: none;
            border-radius: 12px; /* æ›´åœ†æ¶¦ */
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            height: 36px;
            transition: all 0.2s cubic-bezier(0.4, 0.0, 0.2, 1); /* è‹¹æœåŠ¨ç”»æ›²çº¿ */
            white-space: nowrap;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1); /* è‹¹æœé£ç«‹ä½“é˜´å½± */
        }
        
        /* ğŸ è‹¹æœé£æ ¼æ¬¡è¦æŒ‰é’®ç»„ - å‚ç›´å¸ƒå±€ */
        .secondary-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .secondary-actions .btn {
            height: 32px;
            font-size: 13px;
            font-weight: 400;
            border-radius: 12px;
        }
        
        /* ğŸ è‹¹æœé£æ ¼ä¸»æŒ‰é’® */
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); /* è‹¹æœé£æ¸å˜ */
            color: white;
            box-shadow: 0 3px 6px rgba(59, 130, 246, 0.25), 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(37, 99, 235, 0.2);
        }
        
        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3), 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        
        /* ğŸ è‹¹æœé£æ ¼æ¬¡è¦æŒ‰é’® */
        .btn-secondary {
            background: #ffffff;
            color: #6b7280;
            border: 1px solid rgba(0, 0, 0, 0.08);
        }
        
        .btn-secondary:hover {
            background: #f8fafc;
            color: #374151;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.12);
        }
        
        .btn-export {
            background: #34C759; /* ğŸ¯ å¯¼å‡ºæŒ‰é’® - ç»¿è‰² */
            color: white;
            border: 1px solid #2eac4a;
        }
        
        .btn-export:hover {
            background: #2eac4a; /* ğŸ¯ æ‚¬åœ - æ·±ç»¿è‰² */
        }
        
        /* ğŸ è‹¹æœé£æ ¼ç»Ÿè®¡å¡ç‰‡ - ä¸ä¸Šæ–¹ç»„ä»¶å®Œå…¨å¯¹é½ */
        .stats {
            background: rgba(248, 249, 250, 0.85);
            border: 1px solid rgba(0, 0, 0, 0.04);
            border-radius: 16px;
            padding: 20px 24px;
            margin-bottom: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04), 0 2px 4px rgba(0, 0, 0, 0.02);
            display: grid;
            grid-template-columns: 1fr auto; /* ä¸ä¸Šæ–¹ç»„ä»¶ä¿æŒä¸€è‡´ */
            gap: 32px; /* ä¸ä¸Šæ–¹ç»„ä»¶ä¿æŒä¸€è‡´ */
            align-items: center;
        }
        
        /* ğŸ ç»Ÿè®¡æ•°æ®åŒºåŸŸ */
        .stats-data {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 24px;
            align-items: center;
        }
        
        /* ğŸ è‹¹æœé£æ ¼ç»Ÿè®¡é¡¹ */
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        /* ğŸƒ è½»ç›ˆç»Ÿè®¡æ•°å€¼ */
        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #3b82f6;
            line-height: 1.2;
            margin-bottom: 2px;
        }
        
        /* ğŸƒ è½»ç›ˆç»Ÿè®¡æ ‡ç­¾ */
        .stat-label {
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
        }
        
        /* ğŸ å¯¼å‡ºæ“ä½œåŒºåŸŸ - ä¸ä¸Šæ–¹æ“ä½œåŒºåŸŸå¯¹é½ */
        .export-actions {
            display: flex;
            flex-direction: column;
            gap: 8px; /* ä¸ä¸Šæ–¹secondary-actionsä¿æŒä¸€è‡´ */
            padding-left: 32px;
            border-left: 1px solid rgba(0, 0, 0, 0.06); /* ä¸ä¸Šæ–¹åˆ†éš”çº¿ä¿æŒä¸€è‡´ */
            min-width: 200px; /* ä¸ä¸Šæ–¹action-sectionä¿æŒä¸€è‡´ */
        }
        
        /* ğŸ å¯¼å‡ºæŒ‰é’® - ä¸ä¸Šæ–¹æ¬¡è¦æŒ‰é’®å®Œå…¨ä¸€è‡´ */
        .btn-compact {
            font-size: 13px;
            font-weight: 400;
            height: 32px; /* ä¸ä¸Šæ–¹secondary-actionsæŒ‰é’®ä¸€è‡´ */
            padding: 0 16px; /* ä¸ä¸Šæ–¹æŒ‰é’®ä¿æŒä¸€è‡´ */
            border-radius: 12px;
            background: #ffffff;
            color: #6b7280; /* ä¸ä¸Šæ–¹æ¬¡è¦æŒ‰é’®é¢œè‰²ä¸€è‡´ */
            border: 1px solid rgba(0, 0, 0, 0.08); /* ä¸ä¸Šæ–¹æ¬¡è¦æŒ‰é’®ä¸€è‡´ */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1);
            transition: all 0.2s cubic-bezier(0.4, 0.0, 0.2, 1);
            width: 100%; /* å…¨å®½ä¸ä¸Šæ–¹æŒ‰é’®ä¸€è‡´ */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-compact:hover {
            background: #f8fafc;
            color: #374151; /* ä¸ä¸Šæ–¹æ¬¡è¦æŒ‰é’®æ‚¬åœé¢œè‰²ä¸€è‡´ */
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.12);
        }
        
        .wordcloud-container {
            width: 100%;
            height: 600px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: #ffffff;
            position: relative;
            overflow: hidden;
        }
        
        /* è¯äº‘èŠ‚ç‚¹æ ·å¼ - ç«‹ä½“é˜´å½±ä¼˜åŒ–ç‰ˆ */
        .word-node {
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            /* ğŸ¨ ç®€æ´æ— é˜´å½±è®¾è®¡ */
        }
        
        .word-node:hover {
            transform: scale(1.05) translateY(-1px); /* ğŸ¨ è½»å¾®æµ®èµ·æ•ˆæœ */
            /* ğŸ¨ hoveræ—¶å¢å¼ºé˜´å½± */
            filter: drop-shadow(0 6px 16px rgba(0,0,0,0.2)) drop-shadow(0 3px 6px rgba(0,0,0,0.3)) !important;
        }
        
        .word-node.core {
            fill: #007AFF; /* ğŸ¨ æ ¸å¿ƒèŠ‚ç‚¹ - è“è‰²ï¼Œä¸å‚è€ƒå›¾ä¸­å¿ƒèŠ‚ç‚¹ä¸€è‡´ */
            stroke: rgba(255,255,255,0.95);
            stroke-width: 2;
            /* ğŸ¨ ä¼˜é›…ç«‹ä½“é˜´å½± - è‹¹æœé£æ ¼æ·±åº¦æ„Ÿ */
            filter: drop-shadow(0 4px 12px rgba(0,122,255,0.25)) drop-shadow(0 2px 4px rgba(0,122,255,0.4));
        }
        
        .word-node.fuzzy {
            /* åŠ¨æ€å¡«å……ç”±getDynamicMorandiColorå‡½æ•°è®¡ç®— */
            stroke: rgba(255,255,255,0.7);
            stroke-width: 1.5;
            transition: all 0.4s ease;
            /* ğŸ¨ æŸ”å’Œç°è‰²é˜´å½± - ä¸ç°è‰²è°ƒèŠ‚ç‚¹åŒ¹é… */
            filter: drop-shadow(0 3px 8px rgba(0,0,0,0.15)) drop-shadow(0 1px 3px rgba(0,0,0,0.2));
        }
        
        .word-node.fuzzy.dimmed {
            opacity: 0.5 !important; /* ç”¨é€æ˜åº¦è€Œéè‰²å½©å˜åŒ– */
        }
        
        .word-node.fuzzy.active-path {
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.2)) brightness(1.05);
            animation: gentle-pulse 2s ease-in-out infinite;
        }
        
        /* ğŸ”— èåˆèŠ‚ç‚¹æ ·å¼ */
        .word-node.fusion {
            fill: #8A8A8A; /* ğŸ¨ èåˆèŠ‚ç‚¹ - æµ…ç°è‰²ï¼Œä¸å‚è€ƒå›¾æ¬¡è¦èŠ‚ç‚¹ä¸€è‡´ */
            stroke: rgba(255,255,255,0.8);
            stroke-width: 2;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.15));
            position: relative;
        }
        
        .word-node.fusion::before {
            content: "âš¡";
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 8px;
            color: #8A8A8A; /* ğŸ¨ å›¾æ ‡é¢œè‰² - æµ…ç°è‰² */
            pointer-events: none;
        }
        
        .word-node.selected {
            filter: drop-shadow(0 3px 8px rgba(0,0,0,0.25)) brightness(1.1);
        }
        
        @keyframes gentle-pulse {
            0%, 100% { 
                filter: drop-shadow(0 2px 6px rgba(0,0,0,0.2)) brightness(1.05);
            }
            50% { 
                filter: drop-shadow(0 3px 8px rgba(0,0,0,0.25)) brightness(1.1);
            }
        }
        
        .word-node:hover {
            stroke-width: 3;
            transform: scale(1.05);
        }
        
        .word-text {
            text-anchor: middle;
            dominant-baseline: central;
            fill: white;
            font-weight: 500; /* ğŸ è‹¹æœæ¨èçš„ä¸­ç­‰å­—é‡ï¼Œæ›´ç²¾è‡´ */
            pointer-events: none;
            /* ğŸ¨ ä¼˜é›…æ–‡å­—é˜´å½± - è½»å¾®æ·±åº¦æ„Ÿ */
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.25));
            -webkit-font-smoothing: antialiased; /* ğŸ è‹¹æœå­—ä½“å¹³æ»‘ */
            /* ğŸ å®Œæ•´è‹¹æœå­—ä½“æ ˆ - ä¸­è‹±æ–‡å®Œç¾æ”¯æŒ */
            font-family: 
                -apple-system,
                BlinkMacSystemFont,
                "SF Pro Display",         /* ğŸ è‹¹æœä¸“ä¸šå­—ä½“ */
                "SF Pro Text",            /* ğŸ è‹¹æœæ–‡æœ¬å­—ä½“ */
                "PingFang SC",            /* ğŸ è‹¹æœä¸­æ–‡å­—ä½“ */
                "Helvetica Neue",
                "Source Han Sans CN",
                sans-serif;
            letter-spacing: -0.005em; /* ğŸ è‹¹æœé£æ ¼ç´§å¯†å­—è· */
            /* ğŸ¨ ç®€æ´æ–‡å­—è®¾è®¡ */
        }
        
        .expand-btn {
            fill: rgba(0,122,255,0.15); /* ğŸ¨ æ‰©å±•æŒ‰é’® - è“è‰²åŠé€æ˜ï¼Œä¸ä¸­å¿ƒèŠ‚ç‚¹ä¸€è‡´ */
            stroke: #007AFF; /* ğŸ¨ è¾¹æ¡† - è“è‰²ï¼Œä¸ä¸­å¿ƒèŠ‚ç‚¹ä¸€è‡´ */
            stroke-width: 1.5;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .word-group:hover .expand-btn {
            opacity: 0.9;
        }
        
        .expand-btn:hover {
            opacity: 1;
            fill: rgba(0,122,255,0.25);
            transform: scale(1.05);
        }
        
        .expand-icon {
            fill: #007AFF; /* ğŸ¨ æ‰©å±•å›¾æ ‡ - è“è‰²ï¼Œä¸ä¸­å¿ƒèŠ‚ç‚¹ä¸€è‡´ */
            text-anchor: middle;
            dominant-baseline: central;
            font-size: 10px;
            font-weight: 600;
            pointer-events: none;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
        }
        
        .selected-words {
            margin-top: 20px;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        
        .selected-words h3 {
            margin: 0 0 12px 0;
            color: #495057;
            font-size: 16px;
        }
        
        .selected-word-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .selected-word-tag {
            background: #007AFF; /* ğŸ¨ é€‰ä¸­æ ‡ç­¾ - è“è‰²ï¼Œä¸ä¸­å¿ƒèŠ‚ç‚¹ä¸€è‡´ */
            color: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        
        /* ğŸ è‹¹æœé£æ ¼è°ƒè¯•é¢æ¿ - ä¸ä¸Šæ–¹ç»„ä»¶ç»Ÿä¸€ */
        .debug-panel {
            margin-top: 20px;
            background: rgba(248, 249, 250, 0.85);
            border: 1px solid rgba(0, 0, 0, 0.04);
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.04), 0 2px 4px rgba(0, 0, 0, 0.02);
        }
        
        .debug-panel h3 {
            margin: 0 0 14px 0;
            color: #374151;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: -0.01em;
        }
        
        .debug-info {
            font-family: 'SF Mono', Monaco, Menlo, monospace;
            font-size: 13px;
            line-height: 1.5;
            color: #6b7280;
            background: rgba(255, 255, 255, 0.6);
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid rgba(0, 0, 0, 0.03);
        }
        
        /* ğŸ è‹¹æœé£æ ¼æ ¸å¿ƒè¯èŠ‚ç‚¹åˆ—è¡¨ */
        .core-nodes-list {
            margin-bottom: 18px;
            padding: 12px 14px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(0, 0, 0, 0.03);
            color: #6b7280;
            font-size: 14px;
            line-height: 1.5;
        }
        
        /* è¿çº¿æ ·å¼ - ä¼˜é›…æ›²çº¿ç‰ˆ */
        .word-link {
            stroke: #8E8E93;
            stroke-width: 2;
            stroke-opacity: 0.4;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            fill: none;
            stroke-linecap: round;
        }
        
        .word-link:hover {
            stroke: #FF3B30;
            stroke-width: 3;
            stroke-opacity: 0.8;
            /* ç®€æ´è¿çº¿è®¾è®¡ */
        }
        
        .word-link.selected {
            stroke: #FF3B30;
            stroke-width: 3;
            stroke-opacity: 1;
            /* ç®€æ´é€‰ä¸­è¿çº¿è®¾è®¡ */
        }
        
        /* è¯­ä¹‰è·¯å¾„è¿çº¿æ ·å¼ - å‚è€ƒå›¾é…è‰²æ–¹æ¡ˆ */
        .semantic-link {
            pointer-events: none;
            transition: all 0.4s ease;
        }
        
        /* ä¸»è¦è¿æ¥ - è“è‰²å®çº¿ï¼Œè¡¨ç¤ºå¼ºå…³è”ï¼ˆå¦‚ï¼šè¿åŠ¨åº·å¤â†’åŠŸèƒ½æ¢å¤è®­ç»ƒï¼‰ */
        .semantic-link.solid {
            stroke: #007AFF; /* ğŸ¨ è“è‰²å®çº¿ - ä¸ä¸­å¿ƒèŠ‚ç‚¹ä¸€è‡´ */
            stroke-width: 2;
            stroke-opacity: 0.8;
            stroke-dasharray: none;
            filter: drop-shadow(0 1px 3px rgba(0,122,255,0.3)); /* ğŸ¨ æ·»åŠ è“è‰²é˜´å½± */
        }
        
        /* æ¬¡è¦è¿æ¥ - ç°è‰²è™šçº¿ï¼Œè¡¨ç¤ºä¸€èˆ¬å…³è”ï¼ˆå¦‚ï¼šè¿åŠ¨åº·å¤â†’åŠŸèƒ½æ€§ï¼‰ */
        .semantic-link.dashed {
            stroke: #666; /* ğŸ¨ ç°è‰²è™šçº¿ - è¡¨ç¤ºæ¬¡è¦å…³è” */
            stroke-width: 1.5;
            stroke-opacity: 0.7;
            stroke-dasharray: 6,3;
        }
        
        /* è¿çº¿æ¨¡å¼æ ·å¼ */
        .connection-mode {
            background: #007AFF !important; /* ğŸ¨ è“è‰²ï¼Œä¸ä¸­å¿ƒèŠ‚ç‚¹ä¸€è‡´ */
            color: white;
        }
        
        .node-connecting {
            fill: #007AFF !important; /* ğŸ¨ è“è‰²ï¼Œä¸ä¸­å¿ƒèŠ‚ç‚¹ä¸€è‡´ */
            stroke: #007AFF; /* ğŸ¨ è“è‰²ï¼Œä¸ä¸­å¿ƒèŠ‚ç‚¹ä¸€è‡´ */
            stroke-width: 2;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        
        /* æ‹–æ‹½çŠ¶æ€æ ·å¼ */
        .word-group.dragging {
            /* ç®€æ´æ§åˆ¶é¢æ¿è®¾è®¡ */
            z-index: 1000;
        }
        
        .word-group.dragging .word-node {
            stroke-width: 3;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>è¯äº‘æµ‹è¯•å™¨</h1>
            <p>åŸºäºè¯­ä¹‰è·¯å¾„çš„æ™ºèƒ½è¯æ±‡æ‰©å±•ä¸å¯è§†åŒ–</p>
        </div>
        
        <!-- ğŸ ä¸€ä½“åŒ–æ§åˆ¶ç»„ä»¶ -->
        <div class="control-unified">
            <!-- é…ç½®åŒºåŸŸ -->
            <div class="config-section">
                <div class="config-grid">
                    <div class="input-group">
                        <label for="coreWords">æ ¸å¿ƒè¯æ±‡</label>
                        <input type="text" id="coreWords" placeholder="æ½®æ±•èœ">
                    </div>
                    
                    <div class="input-group">
                        <label for="newCoreWord">åŠ¨æ€æ·»åŠ </label>
                        <input type="text" id="newCoreWord" placeholder="è¾“å…¥æ–°æ ¸å¿ƒè¯" onkeypress="handleNewWordKeypress(event)">
                    </div>
                    
                    <div class="input-group">
                        <label for="nodeCount">èŠ‚ç‚¹æ•°é‡</label>
                        <select id="nodeCount">
                            <option value="10">ç²¾ç®€(10ä¸ª)</option>
                            <option value="15" selected>é€‚ä¸­(15ä¸ª)</option>
                            <option value="25">ä¸°å¯Œ(25ä¸ª)</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="layoutMode">å¸ƒå±€æ¨¡å¼</label>
                        <select id="layoutMode">
                            <option value="radial">å¾„å‘åˆ†å¸ƒ</option>
                            <option value="cluster">èšç±»åˆ†å¸ƒ</option>
                            <option value="force">è‡ªç”±åŠ›å¯¼å‘</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- æ“ä½œåŒºåŸŸ -->
            <div class="action-section">
                <button class="btn btn-primary" onclick="generateWordCloud()">ç”Ÿæˆè¯äº‘</button>
                <div class="secondary-actions">
                    <button class="btn btn-secondary" onclick="addNewCoreWord()">æ·»åŠ èŠ‚ç‚¹</button>
                    <button class="btn btn-secondary" onclick="clearSelection()">æ¸…ç©ºé€‰æ‹©</button>
                    <button class="btn btn-secondary" onclick="toggleConnectionMode()" id="connectionBtn">è¿çº¿æ¨¡å¼</button>
                </div>
            </div>
        </div>
        
        <div class="stats">
            <!-- ç»Ÿè®¡æ•°æ®åŒºåŸŸ -->
            <div class="stats-data">
                <div class="stat-item">
                    <div class="stat-value" id="totalNodes">0</div>
                    <div class="stat-label">æ€»èŠ‚ç‚¹æ•°</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="selectedNodes">0</div>
                    <div class="stat-label">å·²é€‰æ‹©</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="coreNodes">0</div>
                    <div class="stat-label">æ ¸å¿ƒè¯</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="fuzzyNodes">0</div>
                    <div class="stat-label">æ¨¡ç³Šè¯</div>
                </div>
            </div>
            
            <!-- ğŸ å¯¼å‡ºæ“ä½œåŒºåŸŸ -->
            <div class="export-actions">
                <button class="btn-compact" onclick="exportOutline()" title="å¯¼å‡ºMarkdownå¤§çº²">
                    å¯¼å‡ºå¤§çº²
                </button>
                <button class="btn-compact" onclick="exportHighResImage()" title="å¯¼å‡ºé«˜æ¸…PNGå›¾è°±">
                    å¯¼å‡ºå›¾è°±
                </button>
            </div>
        </div>
        
        <div class="wordcloud-container" id="wordcloudContainer"></div>
        
        <div class="selected-words" id="selectedWords" style="display: none;">
            <h3>å·²é€‰æ‹©çš„è¯æ±‡</h3>
            <div class="selected-word-tags" id="selectedWordTags"></div>
            <p style="margin-top: 12px; font-size: 12px; color: #6c757d;">
                äº¤äº’æç¤ºï¼š<br>
                â€¢ <strong>å•å‡»èŠ‚ç‚¹</strong>ï¼šé€‰æ‹©/å–æ¶ˆé€‰æ‹©è¯æ±‡<br>
                â€¢ <strong>åŒå‡»èŠ‚ç‚¹</strong>æˆ–<strong>ç‚¹å‡»+å·</strong>ï¼šæ‰©å±•ç›¸å…³è¯æ±‡<br>
                â€¢ <strong>è¿çº¿æ¨¡å¼</strong>ï¼šå…ˆç‚¹å‡»"è¿çº¿æ¨¡å¼"ï¼Œç„¶åä¾æ¬¡ç‚¹å‡»ä¸¤ä¸ªèŠ‚ç‚¹å»ºç«‹å…³ç³»è¿çº¿<br>
                â€¢ <strong>å•å‡»è¿çº¿</strong>ï¼šé€‰æ‹©/å–æ¶ˆé€‰æ‹©è¿çº¿<br>
                â€¢ <strong>è¯­ä¹‰è¿çº¿</strong>ï¼šæµ…è™šçº¿è¡¨ç¤ºAIå»ºè®®å…³ç³»ï¼Œç‚¹å‡»+å·æ‰©å±•åå˜ä¸ºå®çº¿è¡¨ç¤ºç¡®è®¤è·¯å¾„<br>
                â€¢ <strong>å›¾è°±æ“ä½œ</strong>ï¼šé¼ æ ‡æ‹–æ‹½å¹³ç§»ã€æ»šè½®ç¼©æ”¾ã€åŒå‡»é‡ç½®è§†å›¾
            </p>
        </div>
        
        <div class="debug-panel">
            <h3>å½“å‰æ ¸å¿ƒè¯èŠ‚ç‚¹</h3>
            <div id="coreNodesList" class="core-nodes-list">
                ç­‰å¾…æ·»åŠ æ ¸å¿ƒè¯...
            </div>
            
            <h3>è°ƒè¯•ä¿¡æ¯</h3>
            <div class="debug-info" id="debugInfo">
                ç­‰å¾…ç”Ÿæˆè¯äº‘...
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€çŠ¶æ€
        let wordCloudData = {
            nodes: [],
            links: [], // ç”¨æˆ·åˆ›å»ºçš„è¿çº¿
            semanticLinks: [], // è¯­ä¹‰è·¯å¾„è¿çº¿
            selectedNodes: [],
            selectedLinks: [], // é€‰ä¸­çš„è¿çº¿
            simulation: null,
            connectionMode: false, // è¿çº¿æ¨¡å¼å¼€å…³
            svgContainer: null, // SVGå®¹å™¨å¼•ç”¨
            nodesGroup: null, // èŠ‚ç‚¹ç»„å¼•ç”¨
            linksGroup: null, // è¿çº¿ç»„å¼•ç”¨
            // ğŸ¯ èšå…‰ç¯æ•ˆåº”çŠ¶æ€ç®¡ç†
            focusSystem: {
                activeExpansionPath: null, // å½“å‰æ´»è·ƒçš„æ‰©å±•è·¯å¾„
                focusedNodeId: null, // å½“å‰èšç„¦çš„èŠ‚ç‚¹ID
                lastExpansionTime: 0, // æœ€åä¸€æ¬¡æ‰©å±•æ—¶é—´
                dimmedNodes: new Set(), // å·²æ·¡åŒ–çš„èŠ‚ç‚¹é›†åˆ
                dimmedLinks: new Set() // å·²æ·¡åŒ–çš„é“¾æ¥é›†åˆ
            }
        };
        
        // ğŸ¯ æ™ºèƒ½è·¯å¾„ç»•é¿ç®—æ³•ï¼šä¸ºæ–°èŠ‚ç‚¹è®¡ç®—æ— å†²çªä½ç½®
        function calculateAvoidancePosition(parentNode, existingNodes, baseAngle, baseRadius) {
            const parentX = parentNode.x || (window.innerWidth / 2);
            const parentY = parentNode.y || (window.innerHeight / 2);
            
            // ğŸ¯ ç´§å‡‘æœç´¢ï¼šä¼˜å…ˆä¿æŒç´§å‡‘ï¼Œå†é€æ­¥æ‰©å¤§èŒƒå›´
            for (let radiusMultiplier = 1; radiusMultiplier <= 2.5; radiusMultiplier++) {
                const searchRadius = baseRadius * radiusMultiplier;
                
                // ğŸ¯ æ›´å¯†é›†çš„è§’åº¦æœç´¢ï¼Œç¡®ä¿æ‰¾åˆ°æœ€ä½³ä½ç½®
                for (let angleOffset = 0; angleOffset <= Math.PI; angleOffset += Math.PI / 18) {
                    const angles = angleOffset === 0 ? [baseAngle] : [baseAngle + angleOffset, baseAngle - angleOffset];
                    
                    for (const angle of angles) {
                        const candidateX = parentX + Math.cos(angle) * searchRadius;
                        const candidateY = parentY + Math.sin(angle) * searchRadius;
                        
                        // æ£€æŸ¥ä¸ç°æœ‰èŠ‚ç‚¹çš„æœ€å°è·ç¦»
                        let minDistance = Infinity;
                        for (const node of existingNodes) {
                            if (node.id === parentNode.id) continue;
                            const dx = candidateX - (node.x || 0);
                            const dy = candidateY - (node.y || 0);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            minDistance = Math.min(minDistance, distance);
                        }
                        
                        // ğŸ¯ ç´§å¯†æ’åˆ—æ£€æµ‹ï¼šå…è®¸æ›´è¿‘è·ç¦»ï¼Œä½†é¿å…é‡å 
                        const nodeRadius = 28; // ç¨å¾®å‡å°æ£€æµ‹åŠå¾„
                        if (minDistance > nodeRadius * 2.0) { // è¿›ä¸€æ­¥å‡å°é—´è·ï¼Œæ›´ç´§å‡‘
                            return { x: candidateX, y: candidateY };
                        }
                    }
                }
            }
            
            // å›é€€æ–¹æ¡ˆï¼šéšæœºä½ç½®ä½†ä¿æŒä¸€å®šè·ç¦»
            const fallbackAngle = Math.random() * Math.PI * 2;
            const fallbackRadius = baseRadius * (2 + Math.random());
            return {
                x: parentX + Math.cos(fallbackAngle) * fallbackRadius,
                y: parentY + Math.sin(fallbackAngle) * fallbackRadius
            };
        }
        
        // ğŸ”§ åŠ¨æ€simulationæ›´æ–°ï¼šå¢é‡å¼æ·»åŠ èŠ‚ç‚¹ï¼Œé¿å…é‡ç½®
        function updateSimulationWithNewNodes(newNodes) {
            if (!wordCloudData.simulation) {
                console.warn('âš ï¸ Simulationæœªåˆå§‹åŒ–ï¼Œå°†è§¦å‘å®Œæ•´é‡æ–°æ¸²æŸ“');
                renderWordCloud();
                return;
            }
            
            // ğŸ’¡ D3æœ€ä½³å®è·µï¼šä½¿ç”¨.nodes()æ›´æ–°è€Œä¸æ˜¯é‡æ–°åˆ›å»º
            wordCloudData.simulation
                .nodes(wordCloudData.nodes)
                .alpha(0.3) // é€‚åº¦é‡å¯åŠ¨èƒ½
                .restart();
                
            console.log(`ğŸ”§ å¢é‡æ›´æ–°simulationï¼šæ–°å¢${newNodes.length}ä¸ªèŠ‚ç‚¹`);
        }
        
        // ğŸ¨ å¢é‡è§†è§‰æ›´æ–°ï¼šD3 Enter/Update/Exitæ¨¡å¼
        function updateVisualization() {
            if (!wordCloudData.nodesGroup || !wordCloudData.linksGroup) {
                console.warn('âš ï¸ SVGç»„æœªåˆå§‹åŒ–ï¼Œæ— æ³•å¢é‡æ›´æ–°');
                return;
            }
            
            // æ›´æ–°è¿çº¿
            const links = wordCloudData.linksGroup
                .selectAll('.semantic-link')
                .data(wordCloudData.semanticLinks, d => `${d.source.id}-${d.target.id}`);
                
            // æ–°è¿çº¿è¿›å…¥
            const linksEnter = links.enter()
                .append('line')
                .attr('class', 'semantic-link')
                .style('stroke', d => d.type === 'solid' ? '#4facfe' : '#a0a0a0')
                .style('stroke-width', d => d.type === 'solid' ? 2 : 1)
                .style('stroke-dasharray', d => d.type === 'dashed' ? '8,4' : 'none')
                .style('opacity', 0);
                
            // è¿çº¿æ›´æ–° + åŠ¨ç”»
            links.merge(linksEnter)
                .transition().duration(300)
                .style('opacity', d => d.type === 'solid' ? 0.8 : 0.5)
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);
                
            // ç§»é™¤æ—§è¿çº¿
            links.exit()
                .transition().duration(200)
                .style('opacity', 0)
                .remove();
            
            // æ›´æ–°èŠ‚ç‚¹
            const nodeGroups = wordCloudData.nodesGroup
                .selectAll('.word-group')
                .data(wordCloudData.nodes, d => d.id);
            
            // æ–°èŠ‚ç‚¹è¿›å…¥
            const nodeGroupsEnter = nodeGroups.enter()
                .append('g')
                .attr('class', 'word-group')
                .style('opacity', 0);
            
            // æ·»åŠ åœ†å½¢èƒŒæ™¯åˆ°æ–°èŠ‚ç‚¹
            nodeGroupsEnter.append('circle')
                .attr('class', d => `word-node ${d.type}`)
                .attr('r', getNodeRadius)
                .style('fill', d => d.type === 'fuzzy' ? getDynamicMorandiColor(d) : null)
                .style('opacity', d => d.type === 'core' ? 1 : Math.max(0.4, 0.4 + d.weight * 0.6));
            
            // æ·»åŠ æ–‡å­—åˆ°æ–°èŠ‚ç‚¹
            nodeGroupsEnter.append('text')
                .attr('class', 'word-text')
                .each(function(d) {
                    const radius = getNodeRadius(d);
                    const textFit = smartTextFit(d.name, radius);
                    const baseFontSize = Math.min(radius * 0.45, 13);
                    
                    d3.select(this)
                        .style('font-size', `${baseFontSize * textFit.scale}px`)
                        .text(textFit.text)
                        .append('title')
                        .text(d.name);
                });
            
            // ğŸ”¡ ä¸ºæ–°èŠ‚ç‚¹æ·»åŠ æ‰©å±•æŒ‰é’®
            const expandBtns = nodeGroupsEnter.append('g')
                .attr('class', 'expand-group')
                .style('opacity', 0.85);
                
            expandBtns.append('circle')
                .attr('class', 'expand-btn')
                .attr('r', 7)
                .attr('cx', d => getNodeRadius(d) * 0.7)
                .attr('cy', d => -getNodeRadius(d) * 0.7)
                .on('click', handleExpandClick);
                
            expandBtns.append('text')
                .attr('class', 'expand-icon')
                .attr('x', d => getNodeRadius(d) * 0.7)
                .attr('y', d => -getNodeRadius(d) * 0.7)
                .text('+');
            
            // èŠ‚ç‚¹æ›´æ–° + åŠ¨ç”»è¿›å…¥
            const allNodeGroups = nodeGroups.merge(nodeGroupsEnter);
            allNodeGroups
                .transition().duration(500)
                .style('opacity', 1)
                .attr('transform', d => `translate(${d.x || 0}, ${d.y || 0})`);
                
            // ç§»é™¤æ—§èŠ‚ç‚¹
            nodeGroups.exit()
                .transition().duration(300)
                .style('opacity', 0)
                .remove();
                
            // ç»‘å®šäº‹ä»¶åˆ°æ–°èŠ‚ç‚¹
            nodeGroupsEnter
                .on('click', handleNodeClick)
                .on('dblclick', handleNodeDoubleClick);
                
            console.log('ğŸ¨ å¢é‡è§†è§‰æ›´æ–°å®Œæˆ');
        }
        
        // ğŸ”¡ æ™ºèƒ½è¿çº¿å‡ ä½•è®¡ç®— - å‚è€ƒD3.jså’ŒGephiçš„æœ€ä½³å®è·µ
        
        // è®¡ç®—åœ†åœˆè¾¹ç¼˜äº¤ç‚¹ - ç¡®ä¿è¿çº¿ç«¯ç‚¹å¯¹é½
        function getCircleEdgePoint(center, target, radius) {
            const dx = target.x - center.x;
            const dy = target.y - center.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance === 0) return { x: center.x, y: center.y };
            
            // å•ä½å‘é‡ * åŠå¾„ = è¾¹ç¼˜ç‚¹
            const ratio = radius / distance;
            return {
                x: center.x + dx * ratio,
                y: center.y + dy * ratio
            };
        }
        
        // ğŸŒ¿ è‡ªç„¶æ›²çº¿è¿çº¿è·¯å¾„ - èŠ‚ç‚¹ä¸­å¿ƒè¿æ¥ï¼Œæ™ºèƒ½é¿è®©
        function calculateNaturalLinkPath(linkData) {
            const source = linkData.source;
            const target = linkData.target;
            
            if (!source || !target || !source.x || !target.x) {
                return 'M0,0 L0,0'; // ä¿æŠ¤æ€§è¿”å›
            }
            
            const dx = target.x - source.x;
            const dy = target.y - source.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            // è·ç¦»å¾ˆè¿‘æ—¶ä½¿ç”¨ç›´çº¿
            if (distance < 80) {
                return `M${source.x},${source.y} L${target.x},${target.y}`;
            }
            
            // ä¸­ç­‰è·ç¦»ä½¿ç”¨è½»å¾®å¼§åº¦
            if (distance < 200) {
                const midX = (source.x + target.x) / 2;
                const midY = (source.y + target.y) / 2;
                
                // è®¡ç®—å‚ç›´åç§»ï¼Œåˆ›é€ è‡ªç„¶å¼§åº¦
                const perpOffset = 15; // è½»å¾®çš„å¼§åº¦
                const perpX = -dy / distance * perpOffset;
                const perpY = dx / distance * perpOffset;
                
                const controlX = midX + perpX;
                const controlY = midY + perpY;
                
                return `M${source.x},${source.y} Q${controlX},${controlY} ${target.x},${target.y}`;
            }
            
            // è¾ƒè¿œè·ç¦»ä½¿ç”¨å…‰æ»‘Så‹æ›²çº¿
            const cp1X = source.x + dx * 0.25;
            const cp1Y = source.y + dy * 0.1;
            const cp2X = target.x - dx * 0.25;
            const cp2Y = target.y - dy * 0.1;
            
            return `M${source.x},${source.y} C${cp1X},${cp1Y} ${cp2X},${cp2Y} ${target.x},${target.y}`;
        }
        
        // ä¿ç•™åŸå‡½æ•°åçš„åˆ«åä»¥å…¼å®¹ç°æœ‰ä»£ç 
        function calculateSmartLinkPath(linkData) {
            return calculateNaturalLinkPath(linkData);
        }
        
        // ğŸ¨ å‚è€ƒå›¾é…è‰²ç³»ç»Ÿ - å®ç°è§†è§‰ä¸€è‡´æ€§
        function getDynamicMorandiColor(node) {
            const pathDepth = node.pathDepth || 1;
            const gatWeight = node.weight || 0.5;
            
            // ğŸ¯ Image #2 é£æ ¼çš„æµ…åˆ°æ·±æ¸å˜ - è½»ç›ˆä¼˜é›…
            const grayLevels = [
                '#E8E8E8', // å±‚çº§1: å¾ˆæµ…ç°ï¼Œå¤–å›´èŠ‚ç‚¹
                '#D0D0D0', // å±‚çº§2: æµ…ç°
                '#B8B8B8', // å±‚çº§3: ä¸­æµ…ç°
                '#A0A0A0', // å±‚çº§4: ä¸­ç­‰ç°
                '#888888', // å±‚çº§5: ä¸­æ·±ç°
                '#707070'  // å±‚çº§6+: æ·±ç°ï¼Œæœ€å†…å±‚
            ];
            
            // ğŸ¨ æ ¹æ®è·¯å¾„æ·±åº¦é€‰æ‹©ç°åº¦çº§åˆ«
            const levelIndex = Math.min(pathDepth - 1, grayLevels.length - 1);
            let baseColor = grayLevels[levelIndex];
            
            // ğŸ¨ æ ¹æ®æƒé‡è¿›è¡Œå¾®è°ƒï¼Œä¿æŒè§†è§‰å±‚æ¬¡
            if (gatWeight < 0.3) {
                // ä½æƒé‡èŠ‚ç‚¹ - æ›´æµ…ä¸€çº§ï¼Œæ›´çªå‡º
                const lighterIndex = Math.max(0, levelIndex - 1);
                baseColor = grayLevels[lighterIndex];
            } else if (gatWeight > 0.7) {
                // é«˜æƒé‡èŠ‚ç‚¹ - æ›´æ·±ä¸€çº§ï¼Œæ›´æ²‰ç¨³
                const darkerIndex = Math.min(grayLevels.length - 1, levelIndex + 1);
                baseColor = grayLevels[darkerIndex];
            }
            
            return baseColor;
        }

        // ğŸ¯ èšå…‰ç¯æ•ˆåº”ç³»ç»Ÿ - æ™ºèƒ½ç„¦ç‚¹ç®¡ç†
        
        // è®¾ç½®æ–°çš„ç„¦ç‚¹è·¯å¾„ï¼šå½“ç”¨æˆ·ç‚¹å‡»èŠ‚ç‚¹æ‰©å±•æ—¶è°ƒç”¨
        function setFocusPath(nodeId, expansionPath) {
            const focusSystem = wordCloudData.focusSystem;
            
            // è®°å½•æ–°çš„æ´»è·ƒçŠ¶æ€
            focusSystem.focusedNodeId = nodeId;
            focusSystem.activeExpansionPath = expansionPath;
            focusSystem.lastExpansionTime = Date.now();
            
            // åº”ç”¨èšå…‰ç¯æ•ˆåº”
            applySpotlightEffect();
        }
        
        // åº”ç”¨èšå…‰ç¯æ•ˆåº”ï¼šæ·¡åŒ–éç„¦ç‚¹å…ƒç´ 
        function applySpotlightEffect() {
            const focusSystem = wordCloudData.focusSystem;
            
            if (!focusSystem.focusedNodeId || !focusSystem.activeExpansionPath) {
                return; // æ— ç„¦ç‚¹æ—¶ä¸å¤„ç†
            }
            
            // è·å–å½“å‰ç„¦ç‚¹è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹ID
            const focusedNodeIds = new Set();
            const focusPath = focusSystem.activeExpansionPath;
            
            // æ·»åŠ ç„¦ç‚¹è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹
            focusPath.forEach(nodeName => {
                const node = wordCloudData.nodes.find(n => n.name === nodeName);
                if (node) focusedNodeIds.add(node.id);
            });
            
            // æ·»åŠ æ ¸å¿ƒèŠ‚ç‚¹ï¼ˆæ°¸è¿œä¿æŒäº®åº¦ï¼‰
            wordCloudData.nodes.forEach(node => {
                if (node.type === 'core') {
                    focusedNodeIds.add(node.id);
                }
            });
            
            // åº”ç”¨æ·¡åŒ–æ•ˆæœåˆ°èŠ‚ç‚¹
            applyNodeDimming(focusedNodeIds);
            
            // åº”ç”¨æ·¡åŒ–æ•ˆæœåˆ°é“¾æ¥  
            applyLinkDimming(focusedNodeIds);
        }
        
        // èŠ‚ç‚¹æ·¡åŒ–é€»è¾‘
        function applyNodeDimming(focusedNodeIds) {
            const svg = d3.select('#wordCloudSvg');
            
            svg.selectAll('.word-group')
                .transition()
                .duration(400)
                .style('opacity', d => {
                    if (focusedNodeIds.has(d.id)) {
                        return d.type === 'core' ? 1 : Math.max(0.4, 0.4 + d.weight * 0.6); // ç„¦ç‚¹èŠ‚ç‚¹ï¼šæ­£å¸¸äº®åº¦
                    } else {
                        return 0.25; // éç„¦ç‚¹èŠ‚ç‚¹ï¼šæ·¡åŒ–åˆ°25%
                    }
                });
        }
        
        // é“¾æ¥æ·¡åŒ–é€»è¾‘
        function applyLinkDimming(focusedNodeIds) {
            const svg = d3.select('#wordCloudSvg');
            
            svg.selectAll('.semantic-link')
                .transition()
                .duration(400)
                .style('stroke-opacity', d => {
                    // æ£€æŸ¥é“¾æ¥çš„ä¸¤ç«¯èŠ‚ç‚¹æ˜¯å¦åœ¨ç„¦ç‚¹è·¯å¾„ä¸­
                    const sourceInFocus = focusedNodeIds.has(d.source.id);
                    const targetInFocus = focusedNodeIds.has(d.target.id);
                    
                    if (sourceInFocus && targetInFocus) {
                        return d.type === 'solid' ? 0.8 : calculateDashedLinkOpacity(d); // ç„¦ç‚¹é“¾æ¥ï¼šæ­£å¸¸é€æ˜åº¦
                    } else if (sourceInFocus || targetInFocus) {
                        return 0.3; // åŠç„¦ç‚¹é“¾æ¥ï¼šä¸­ç­‰é€æ˜åº¦
                    } else {
                        return 0.1; // éç„¦ç‚¹é“¾æ¥ï¼šææ·¡
                    }
                });
        }
        
        // æ¸…é™¤èšå…‰ç¯æ•ˆåº”ï¼šæ¢å¤æ‰€æœ‰å…ƒç´ åˆ°æ­£å¸¸çŠ¶æ€
        function clearSpotlightEffect() {
            const focusSystem = wordCloudData.focusSystem;
            
            // æ¸…é™¤ç„¦ç‚¹çŠ¶æ€
            focusSystem.focusedNodeId = null;
            focusSystem.activeExpansionPath = null;
            focusSystem.dimmedNodes.clear();
            focusSystem.dimmedLinks.clear();
            
            // æ¢å¤æ‰€æœ‰èŠ‚ç‚¹çš„æ­£å¸¸é€æ˜åº¦
            const svg = d3.select('#wordCloudSvg');
            
            svg.selectAll('.word-group')
                .transition()
                .duration(600)
                .style('opacity', d => d.type === 'core' ? 1 : Math.max(0.4, 0.4 + d.weight * 0.6));
                
            svg.selectAll('.semantic-link')
                .transition()
                .duration(600)
                .style('stroke-opacity', d => d.type === 'solid' ? 0.8 : calculateDashedLinkOpacity(d));
        }
        
        // Graphiti API çœŸå®è¯­ä¹‰æ‰©å±• - åŸºäºOpenAIæ™ºèƒ½ç”Ÿæˆ
        
        // ğŸ”µ APIè¶…æ—¶æ§åˆ¶ï¼šé¿å…æ— é™å¡é¡¿
        function createTimeoutPromise(ms) {
            return new Promise((_, reject) => 
                setTimeout(() => reject(new Error(`APIè¯·æ±‚è¶…æ—¶(${ms}ms)`)), ms)
            );
        }
        
        // æ„å»ºå¯¹è¯å†å² - è®©AIæ„ŸçŸ¥å®Œæ•´çš„æ¦‚å¿µæ¼”è¿›è¿‡ç¨‹
        function buildConversationHistory(semanticPath, currentWord, limit) {
            const messages = [];
            
            if (semanticPath.length === 1) {
                // ç¬¬ä¸€çº§ï¼šå…ƒæ¦‚å¿µæ‰©å±•
                messages.push({
                    role: 'user',
                    content: `è¯·ä¸ºæ¦‚å¿µ"${currentWord}"ç”Ÿæˆ${limit}ä¸ªç›¸å…³çš„æ¦‚å¿µè¯æ±‡ã€‚

è¦æ±‚ï¼š
1. å¤šç»´åº¦å…³è”ï¼šä»ä¸åŒè§’åº¦æ‰¾åˆ°ä¸"${currentWord}"ç›¸å…³çš„æ¦‚å¿µ
2. çœŸå®æ€§åŸåˆ™ï¼šåªä½¿ç”¨æ—¥å¸¸è¯­è¨€ä¸­çœŸå®å­˜åœ¨çš„æ¦‚å¿µè¯æ±‡ï¼Œç¦æ­¢åˆ»æ„ç»„åˆåˆ›é€ è¯æ±‡
3. è¯æ±‡è§„æ ¼ï¼š2-3å­—ä¸­æ–‡è¯æ±‡ï¼Œå¦‚"éŸ³ä¹"ã€"è‰ºæœ¯"ã€"æƒ…æ„Ÿ"ç­‰è‡ªç„¶æ¦‚å¿µ
4. é¿å…å¤åˆåˆ›é€ ï¼šä¸è¦ç”Ÿæˆ"éŸ³åˆƒå¯¹å³™"ã€"æ’•è£‚èŠ‚æ‹"è¿™ç±»åˆ»æ„ç»„åˆçš„è¯æ±‡
5. æŒ‰è¯­ä¹‰å…³è”å¼ºåº¦æ’åº

ç›´æ¥è¿”å›${limit}ä¸ªçœŸå®å­˜åœ¨çš„æ¦‚å¿µè¯æ±‡ï¼Œé€—å·åˆ†éš”ã€‚`
                });
            } else {
                // å¤šçº§ï¼šåŸºäºè¯­ä¹‰è·¯å¾„çš„ä¸Šä¸‹æ–‡æ‰©å±•
                // æ·»åŠ å†å²æ‰©å±•è®°å½•
                for (let i = 0; i < semanticPath.length - 1; i++) {
                    const fromConcept = semanticPath[i];
                    const toConcept = semanticPath[i + 1];
                    
                    messages.push({
                        role: 'user', 
                        content: `åŸºäº"${fromConcept}"æ‰©å±•ç›¸å…³æ¦‚å¿µ`
                    });
                    
                    // ä½¿ç”¨çœŸå®çš„AIå†å²å›åº”ï¼ˆä»å®é™…APIè·å–ï¼‰
                    // æ³¨æ„ï¼šè¿™é‡Œåº”è¯¥ä»çœŸå®çš„conversation historyè·å–ï¼Œè€Œä¸æ˜¯æ¨¡æ‹Ÿæ•°æ®
                }
                
                // å½“å‰æ‰©å±•è¯·æ±‚
                messages.push({
                    role: 'user',
                    content: `åŸºäºå®Œæ•´è¯­ä¹‰è·¯å¾„"${semanticPath.join(' â†’ ')}"è¿›è¡Œå¤šé‡è¯­ä¹‰èåˆæ‰©å±•ã€‚

å¤šé‡è¯­ä¹‰æƒé‡åˆ†æï¼š
${semanticPath.map((word, index) => {
    if (index === semanticPath.length - 1) {
        return `- "${word}" (å½“å‰ç„¦ç‚¹ï¼Œæƒé‡40%) - ä¸»è¦æ‰©å±•æ–¹å‘`;
    } else {
        const weight = Math.round(60 / (semanticPath.length - 1));
        return `- "${word}" (è·¯å¾„å½±å“ï¼Œæƒé‡${weight}%) - è¯­ä¹‰ç‰¹å¾å½±å“`;
    }
}).join('\n')}

èåˆæ‰©å±•åŸåˆ™ï¼š
1. å¤šé‡è¯­ä¹‰èåˆï¼šä¸æ˜¯å•çº¯çš„"${currentWord}"æ‰©å±•ï¼Œè€Œæ˜¯"${semanticPath.join('+')}å¤åˆè¯­ä¹‰ç©ºé—´"ä¸­çš„æ¦‚å¿µ
2. çœŸå®æ€§ä¸æ·±åº¦å¹³è¡¡ï¼šä½¿ç”¨çœŸå®å­˜åœ¨çš„æ¦‚å¿µï¼Œä½†å…è®¸ä¸“ä¸šæœ¯è¯­å’Œæ–‡å­¦æ¦‚å¿µï¼Œå¦‚"ç—…æ€ç¾å­¦"ã€"å…ˆé”‹è‰ºæœ¯"ç­‰
3. ç¦æ­¢äººå·¥ç»„åˆï¼šé¿å…"éŸ³åˆƒæ’•è£‚"ã€"æµè¡ŒéŸ³åˆƒ"è¿™ç±»ç”Ÿç¡¬ç»„åˆè¯
4. è¯­ä¹‰ç‰¹å¾ç»§æ‰¿ï¼šæ¯ä¸ªæ¦‚å¿µéƒ½åº”ä½“ç°æ•´æ¡è·¯å¾„çš„å¤åˆç‰¹å¾

é¢„æœŸæ•ˆæœç¤ºä¾‹ï¼š
- å¦‚æœè·¯å¾„æ˜¯"æ¤åæ—æªâ†’éŸ³ä¹â†’æµè¡Œ"ï¼Œåº”ç”Ÿæˆå¸¦æœ‰"æ¤åæ—æªç‰¹è‰²+éŸ³ä¹å±æ€§"çš„æµè¡Œæ¦‚å¿µ
- è€Œä¸æ˜¯é€šç”¨çš„æµè¡Œæ¦‚å¿µ

è¿”å›${limit}ä¸ªä½“ç°å¤šé‡è¯­ä¹‰èåˆçš„æ¦‚å¿µè¯æ±‡ï¼Œ2-3å­—ä¸ºä¸»ï¼Œé€—å·åˆ†éš”ã€‚`
                });
            }
            
            return messages;
        }
        
        // Graphiti APIçœŸå®è¯­ä¹‰æ‰©å±• - åŸºäºOpenAIæ™ºèƒ½ç”Ÿæˆ
        async function getConceptNetConcepts(nodeOrWord, limit = 8) {
            const coreWord = typeof nodeOrWord === 'string' ? nodeOrWord : nodeOrWord.name;
            
            // æ„å»ºå®Œæ•´è¯­ä¹‰è·¯å¾„
            let semanticPath = [];
            if (typeof nodeOrWord === 'object' && nodeOrWord.semanticPath) {
                console.log('ğŸ› DEBUG: nodeOrWord.semanticPath =', nodeOrWord.semanticPath);
                
                semanticPath = nodeOrWord.semanticPath.map(pathNode => {
                    // ç¡®ä¿æ¯ä¸ªè·¯å¾„èŠ‚ç‚¹æ­£ç¡®å¤„ç† - ä½¿ç”¨åç«¯æœŸæœ›çš„æ ¼å¼
                    if (typeof pathNode === 'string') {
                        return {concept: pathNode, weight: 1.0};
                    } else {
                        return {concept: pathNode.name || pathNode, weight: pathNode.weight || 1.0};
                    }
                });
                
                console.log('ğŸ› DEBUG: æ„å»ºçš„semanticPath =', semanticPath);
            }
            
            console.log(`ğŸ§  GATè·¯å¾„æƒé‡æ‰©å±•: ${coreWord}, è·¯å¾„é•¿åº¦: ${semanticPath.length}, é™åˆ¶: ${limit}`);
            
            try {
                
                const response = await fetch('/api/path-expand', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        current_concept: coreWord,
                        semantic_path: semanticPath,
                        target_count: limit
                    })
                });
                
                if (!response.ok) {
                    console.error(`Graphiti APIè°ƒç”¨å¤±è´¥: ${response.status}`);
                    return [];
                }
                
                const data = await response.json();
                
                if (!data.success) {
                    console.warn('Graphiti APIè¿”å›å¤±è´¥:', data.error);
                    return [];
                }
                
                console.log(`ğŸ¨ GraphitiåŸå§‹å›å¤:`, data.data);
                
                // è§£æGAT APIè¿”å›çš„è¯­ä¹‰ç»“æ„
                const concepts = [];
                
                // å¤„ç†GATç”Ÿæˆçš„æ¦‚å¿µ
                if (data.data.concepts) {
                    data.data.concepts.forEach((item, index) => {
                        concepts.push({
                            word: item.name,
                            weight: item.weight,  // ä½¿ç”¨GATè®¡ç®—çš„çœŸå®æƒé‡
                            relation: 'gat_semantic',
                            source: 'gat_path_api',
                            originalPrompt: coreWord,
                            pathWeight: item.total_path_weight,
                            attentionFactor: item.path_attention,
                            fullPath: item.full_semantic_path
                        });
                    });
                }
                
                console.log(`âœ… GATæˆåŠŸç”Ÿæˆ ${concepts.length} ä¸ªçœŸå®æ¦‚å¿µ`);
                console.log('ğŸ” ç”Ÿæˆæ¦‚å¿µ:', concepts.map(c => `${c.word}(${c.weight.toFixed(2)})`).join(', '));
                
                return concepts.slice(0, limit);
                
            } catch (error) {
                console.error('Graphiti APIè°ƒç”¨å¼‚å¸¸:', error);
                return [];
            }
        }
        
        // å®Œå…¨åˆ é™¤æ­»æ•°æ®åå¤‡æœºåˆ¶ - ä¸¥æ ¼éµå¾ªåªç”¨APIåŸåˆ™
        
        // ç”Ÿæˆè¯äº‘æ•°æ® - ä¿æŒåŸç‰ˆä¸²è¡Œè°ƒç”¨é€»è¾‘
        async function generateWordCloud() {
            const coreWordsInput = document.getElementById('coreWords').value.trim();
            const nodeCount = parseInt(document.getElementById('nodeCount').value);
            
            if (!coreWordsInput) {
                alert('è¯·è¾“å…¥æ ¸å¿ƒè¯æ±‡');
                return;
            }
            
            const coreWords = coreWordsInput.split(',').map(w => w.trim()).filter(w => w);
            
            // æ¸…ç©ºç°æœ‰æ•°æ®
            wordCloudData.nodes = [];
            wordCloudData.selectedNodes = [];
            
            updateDebugInfo('ğŸ”„ å¼€å§‹ç”Ÿæˆè¯äº‘æ•°æ®...');
            
            try {
                // æ·»åŠ æ ¸å¿ƒè¯ - åˆ†æ•£åˆå§‹ä½ç½®é¿å…å †å 
                const container = document.getElementById('wordcloudContainer');
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                coreWords.forEach((word, index) => {
                    let x, y;
                    
                    if (coreWords.length === 1) {
                        // ğŸ¯ å•ä¸ªæ ¸å¿ƒè¯ï¼šå±…ä¸­æ˜¾ç¤º
                        x = width/2;
                        y = height/2;
                    } else {
                        // ğŸ¯ å¤šä¸ªæ ¸å¿ƒè¯ï¼šä¼˜åŒ–èºæ—‹å¸ƒå±€ï¼Œç¡®ä¿åˆç†é—´è·
                        const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // 137.5Â°é»„é‡‘è§’
                        const angle = index * goldenAngle;
                        // ğŸ”§ ä¿®å¤ï¼šç¡®ä¿æœ€å°é—´è·ï¼Œé¿å…é‡å 
                        const radius = Math.max(80, Math.sqrt(index + 1) * 60); // æœ€å°80pxé—´è·
                        x = width/2 + radius * Math.cos(angle);
                        y = height/2 + radius * Math.sin(angle);
                    }
                    
                    wordCloudData.nodes.push({
                        id: word,
                        name: word,
                        type: 'core',
                        weight: 1.0,
                        source: 'user_input',
                        semanticPath: [word],
                        pathDepth: 1,
                        x: x, // è®¾ç½®åˆå§‹ä½ç½®
                        y: y
                    });
                });
                
                // ä½¿ç”¨GraphitiçœŸå®æ‰©å±•æ¯ä¸ªæ ¸å¿ƒè¯ï¼Œä¿æŒçˆ¶å­å…³ç³» - ä¿æŒåŸç‰ˆä¸²è¡Œè°ƒç”¨
                let allInitialConcepts = [];
                for (const coreWord of coreWords.slice(0, 3)) { // é™åˆ¶æ ¸å¿ƒè¯æ•°é‡é¿å…APIè¿‡è½½
                    // ä¸ºæ ¸å¿ƒè¯åˆ›å»ºä¸´æ—¶èŠ‚ç‚¹å¯¹è±¡ï¼ŒåŒ…å«è¯­ä¹‰è·¯å¾„ä¿¡æ¯
                    const coreNode = {
                        name: coreWord,
                        semanticPath: [coreWord],
                        type: 'core'
                    };
                    const concepts = await getConceptNetConcepts(coreNode, 6);
                    
                    // ä¸ºæ¯ä¸ªæ¦‚å¿µæ ‡è®°å®ƒæ¥è‡ªå“ªä¸ªæ ¸å¿ƒè¯
                    concepts.forEach(concept => {
                        concept.parentCoreWord = coreWord;
                        concept.semanticPath = [coreWord, concept.word];
                    });
                    
                    allInitialConcepts.push(...concepts);
                }
                
                // æŒ‰æƒé‡æ’åºå¹¶é™åˆ¶æ•°é‡
                allInitialConcepts.sort((a, b) => b.weight - a.weight);
                const selectedConcepts = allInitialConcepts.slice(0, nodeCount - coreWords.length);
                
                // æ·»åŠ æ¨¡ç³Šæ¦‚å¿µè¯ï¼Œä½¿ç”¨ç¯å½¢åˆ†å¸ƒé¿å…é‡å 
                selectedConcepts.forEach((concept, index) => {
                    const uniqueId = `${concept.word}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                    
                    // ç¯å½¢åˆ†å¸ƒ - ç¡®ä¿èŠ‚ç‚¹ä¸ä¼šå †å åœ¨ä¸­å¿ƒ
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const ringRadius = 80 + (index % 3) * 40; // 3ä¸ªç¯å±‚ï¼š80, 120, 160
                    const angle = (index * 137.5) * Math.PI / 180; // é»„é‡‘è§’åˆ†å¸ƒ
                    const initialX = centerX + ringRadius * Math.cos(angle);
                    const initialY = centerY + ringRadius * Math.sin(angle);
                    
                    const newNode = {
                        id: uniqueId,
                        name: concept.word,
                        type: 'fuzzy',
                        weight: concept.weight,
                        source: concept.source,
                        relation: concept.relation,
                        parentNode: concept.parentCoreWord,
                        semanticPath: concept.semanticPath,
                        pathDepth: concept.semanticPath.length,
                        x: initialX, // ğŸ”¥ è®¾ç½®åˆå§‹Xä½ç½®
                        y: initialY  // ğŸ”¥ è®¾ç½®åˆå§‹Yä½ç½®
                    };
                    
                    wordCloudData.nodes.push(newNode);
                    
                    // ä¸ºåˆå§‹æ‰©å±•åˆ›å»ºæµ…è™šçº¿ - è¡¨ç¤ºAIå»ºè®®ï¼Œæœªç¡®è®¤
                    const parentNode = wordCloudData.nodes.find(n => n.name === concept.parentCoreWord);
                    if (parentNode) {
                        createSemanticLink(parentNode, newNode, 'dashed');
                    }
                });
                
                // æ˜¾ç¤ºåˆå§‹è¿æ¥å…³ç³»
                const connectionInfo = selectedConcepts.map(concept => 
                    `${concept.word}[${concept.semanticPath.join('â†’')}]`
                ).join(', ');
                
                updateDebugInfo(`âœ… åˆå§‹è¯äº‘ç”Ÿæˆå®Œæˆï¼æ ¸å¿ƒè¯: ${coreWords.length}ä¸ª, æ¨¡ç³Šè¯: ${selectedConcepts.length}ä¸ª\nè¿æ¥å…³ç³»: ${connectionInfo}`);
                
                // æ¸²æŸ“è¯äº‘
                renderWordCloud();
                updateCoreNodesList();
                
            } catch (error) {
                console.error('è¯äº‘ç”Ÿæˆå¤±è´¥:', error);
                updateDebugInfo(`âŒ è¯äº‘ç”Ÿæˆå¤±è´¥: ${error.message}`);
            }
        }
        
        // æ¸²æŸ“è¯äº‘ - ä¼˜åŒ–ç‰ˆæœ¬é¿å…æŠ–åŠ¨
        function renderWordCloud() {
            const container = document.getElementById('wordcloudContainer');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // æ¸…ç©ºå®¹å™¨
            d3.select(container).selectAll('*').remove();
            
            // åˆ›å»ºSVG with å›¾è°±äº¤äº’åŠŸèƒ½
            // ğŸš€ åˆ›å»ºæ— é™å¤§çš„SVGç”»å¸ƒï¼Œå½»åº•æ¶ˆé™¤è¾¹ç•Œ
            const svg = d3.select(container)
                .append('svg')
                .style('width', '100vw') // âœ¨ ä½¿ç”¨è§†çª—å…¨å®½
                .style('height', '100vh') // âœ¨ ä½¿ç”¨è§†çª—å…¨é«˜
                .style('overflow', 'visible') // âœ¨ å…è®¸å…ƒç´ è¶…å‡ºè¾¹ç•Œ
                .attr('viewBox', `${-width*2} ${-height*2} ${width*4} ${height*4}`); // âœ¨ 4å€å¤§çš„è§†å›¾åŒºåŸŸ
                
            const g = svg.append('g');
            
            // æ·»åŠ è¿çº¿ç»„å’ŒèŠ‚ç‚¹ç»„
            const linksGroup = g.append('g').attr('class', 'links-group');
            const nodesGroup = g.append('g').attr('class', 'nodes-group');
            
            // æ·»åŠ ç¼©æ”¾å’Œå¹³ç§»åŠŸèƒ½
            const zoom = d3.zoom()
                .scaleExtent([0.3, 3]) // ç¼©æ”¾èŒƒå›´ï¼š30%åˆ°300%
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // åŒå‡»é‡ç½®è§†å›¾
            svg.on('dblclick.zoom', null); // ç¦ç”¨é»˜è®¤åŒå‡»ç¼©æ”¾
            svg.on('dblclick', () => {
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);
                updateDebugInfo('ğŸ”„ è§†å›¾å·²é‡ç½®åˆ°åˆå§‹ä½ç½®å’Œç¼©æ”¾çº§åˆ«');
            });
            
            // ğŸ¯ å•å‡»ç©ºç™½åŒºåŸŸæ¸…é™¤èšå…‰ç¯æ•ˆåº”
            svg.on('click', (event) => {
                // ç¡®ä¿ç‚¹å‡»çš„æ˜¯SVGèƒŒæ™¯ï¼Œä¸æ˜¯èŠ‚ç‚¹æˆ–é“¾æ¥
                if (event.target === svg.node() || event.target.tagName === 'svg') {
                    clearSpotlightEffect();
                    console.log('ğŸ¯ èšå…‰ç¯æ•ˆåº”å·²æ¸…é™¤');
                    updateDebugInfo('ğŸ¯ å·²æ¸…é™¤èšå…‰ç¯æ•ˆåº”ï¼Œæ¢å¤æ‰€æœ‰å…ƒç´ æ­£å¸¸æ˜¾ç¤º');
                }
            });
            
            // ğŸŒ¿ æœ‰æœºåœ†å½¢åŠ›æ¨¡æ‹Ÿ - è‡ªç„¶åˆ†å¸ƒä¸å—çŸ©å½¢çº¦æŸ
            const centerX = width / 2;
            const centerY = height / 2;
            // ğŸš€ å½»åº•æ¶ˆé™¤è¾¹ç•Œï¼šæ— é™å¤§çš„å¯ç”¨ç©ºé—´
            const maxRadius = Infinity; // âœ¨ æ— é™å¤§çš„è¾¹ç•Œ
            
            const simulation = d3.forceSimulation(wordCloudData.nodes)
                .force('charge', d3.forceManyBody()
                    .strength(-150) // ğŸ¯ å‡å°‘æ’æ–¥åŠ›ï¼Œè®©èŠ‚ç‚¹æ›´ç´§å‡‘
                )
                .force('center', d3.forceCenter(centerX, centerY)) // è½»æŸ”å±…ä¸­ï¼Œé¿å…æ•´ä½“æ¼‚æ•£
                .force('collision', d3.forceCollide()
                    .radius(d => getNodeRadius(d) + 15) // ğŸ¯ å¢åŠ ç¢°æ’åŠå¾„ï¼Œç¡®ä¿æ–‡å­—ä¸é‡å 
                    .strength(0.9) // ğŸ¯ å¢å¼ºç¢°æ’åŠ›åº¦ï¼Œå¼ºåˆ¶åˆ†ç¦»
                )
                // ğŸš€ å½»åº•ç§»é™¤æ‰€æœ‰è¾¹ç•Œçº¦æŸï¼ŒèŠ‚ç‚¹å¯ä»¥æ— é™æ‰©å±•
                // .force('boundary', ...) âœ¨ ä¸å†éœ€è¦ä»»ä½•è¾¹ç•Œé™åˆ¶
                .alphaDecay(0.03);
            
            wordCloudData.simulation = simulation;
            
            // ğŸ¨ æ¸å˜å®šä¹‰ - è¿çº¿è§†è§‰å±‚æ¬¡
            const defs = svg.select('defs').empty() ? svg.append('defs') : svg.select('defs');
            
            // æ¸…é™¤æ—§çš„æ¸å˜
            defs.selectAll('.link-gradient').remove();
            
            // ğŸ¨ ä¸ºæ¯æ¡è¿çº¿åˆ›å»ºå‚è€ƒå›¾é£æ ¼çš„æ¸å˜é…è‰²
            wordCloudData.links.forEach((link, index) => {
                const gradientId = `linkGradient${index}`;
                // ğŸ¨ è“è‰²ä¸­å¿ƒ -> ç°è‰²ç›®æ ‡çš„æ¸å˜ï¼Œä¸å‚è€ƒå›¾å®Œå…¨ä¸€è‡´
                const sourceColor = '#007AFF';  // ğŸ¨ è“è‰²ä¸­å¿ƒèŠ‚ç‚¹
                const targetColor = getDynamicMorandiColor({pathDepth: 2, weight: link.weight});
                
                const gradient = defs.append('linearGradient')
                    .attr('class', 'link-gradient')
                    .attr('id', gradientId)
                    .attr('gradientUnits', 'userSpaceOnUse');
                    
                gradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', sourceColor)
                    .attr('stop-opacity', 0.8); // ğŸ¨ æé«˜èµ·å§‹é€æ˜åº¦
                    
                gradient.append('stop')
                    .attr('offset', '50%')
                    .attr('stop-color', '#C0C0C0') // ğŸ¨ ä¸­é—´è¿‡æ¸¡è‰² - ä¸­ç­‰ç°è‰²
                    .attr('stop-opacity', 0.5);
                    
                gradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', targetColor)
                    .attr('stop-opacity', 0.7); // ğŸ¨ æé«˜ç»“æŸé€æ˜åº¦
            });
            
            // æ¸²æŸ“ç”¨æˆ·åˆ›å»ºçš„è¿çº¿ - å‚è€ƒå›¾é…è‰²æ–¹æ¡ˆ
            const links = linksGroup.selectAll('.word-link')
                .data(wordCloudData.links)
                .enter().append('line')
                .attr('class', 'word-link')
                .style('stroke', '#007AFF') // ğŸ¨ ç”¨æˆ·è¿çº¿ - è“è‰²å®çº¿ï¼Œä¸ä¸­å¿ƒèŠ‚ç‚¹ä¸€è‡´
                .style('stroke-width', d => Math.max(2, d.weight * 3))
                .style('stroke-opacity', 0.8)
                .style('filter', 'drop-shadow(0 1px 3px rgba(0,122,255,0.3))') // ğŸ¨ æ·»åŠ è“è‰²é˜´å½±
                .on('click', handleLinkClick);
            
            // âœ… é‡æ–°å¯ç”¨è¯­ä¹‰è¿çº¿æ¸²æŸ“ï¼Œä¿®å¤Safariæ¸²æŸ“bug
            const semanticLinks = linksGroup.selectAll('.semantic-link')
                .data(wordCloudData.semanticLinks)
                .enter().append('path')
                .attr('class', d => `semantic-link ${d.type}`)
                .attr('fill', 'none') // âœ¨ å…³é”®ä¿®å¤ï¼šç¦ç”¨fillé¿å…é»‘å½±
                .attr('fill-rule', 'nonzero') // âœ¨ Safariä¿®å¤ï¼šä½¿ç”¨nonzeroè§„åˆ™
                .style('shape-rendering', 'geometricPrecision'); // âœ¨ æé«˜æ¸²æŸ“ç²¾åº¦
            
            // åˆ›å»ºèŠ‚ç‚¹ç»„
            const nodeGroups = nodesGroup.selectAll('.word-group')
                .data(wordCloudData.nodes)
                .enter().append('g')
                .attr('class', 'word-group')
                .style('opacity', 0);
            
            // ğŸ–±ï¸ ä¼˜é›…æ‹–æ‹½åŠŸèƒ½ - æ™ºèƒ½è¯†åˆ«æ‹–æ‹½æ„å›¾
            let dragStartTime = 0;
            let isDragging = false;
            let longPressTimer = null;
            
            const dragBehavior = d3.drag()
                .on('start', function(event, d) {
                    dragStartTime = Date.now();
                    isDragging = false;
                    
                    // é•¿æŒ‰æ£€æµ‹ - 200msåæ¿€æ´»æ‹–æ‹½ï¼ˆæ›´å¿«å“åº”ï¼‰
                    longPressTimer = setTimeout(() => {
                        isDragging = true;
                        d3.select(this).classed('dragging', true);
                        updateDebugInfo(`ğŸ–±ï¸ å¼€å§‹æ‹–æ‹½èŠ‚ç‚¹: ${d.name}`);
                        
                        // å›ºå®šèŠ‚ç‚¹ä½ç½®ï¼Œç¦ç”¨åŠ›æ¨¡æ‹Ÿå¯¹æ­¤èŠ‚ç‚¹çš„å½±å“
                        d.fx = d.x;
                        d.fy = d.y;
                        
                        // é‡å¯æ¨¡æ‹Ÿä»¥æ›´æ–°çº¦æŸ
                        if (wordCloudData.simulation) {
                            wordCloudData.simulation.alpha(0.3).restart();
                        }
                    }, 200);
                })
                .on('drag', function(event, d) {
                    if (isDragging) {
                        // æ›´æ–°å›ºå®šä½ç½®
                        d.fx = event.x;
                        d.fy = event.y;
                        
                        // ğŸ”¥ å®æ—¶æ›´æ–°èŠ‚ç‚¹ä½ç½®å’Œç›¸å…³è¿çº¿ï¼ˆç§»é™¤çŸ©å½¢å¤¹é€¼ï¼‰
                        d.x = d.fx;
                        d.y = d.fy;
                        
                        // æ›´æ–°èŠ‚ç‚¹ç»„ä½ç½®
                        d3.select(this).attr('transform', `translate(${d.x}, ${d.y})`);
                    }
                })
                .on('end', function(event, d) {
                    // æ¸…é™¤é•¿æŒ‰è®¡æ—¶å™¨
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                    
                    // æ£€æµ‹æ˜¯å¦ä¸ºå¿«é€Ÿç‚¹å‡»ï¼ˆéæ‹–æ‹½ï¼‰
                    const clickDuration = Date.now() - dragStartTime;
                    
                    if (!isDragging && clickDuration < 200) {
                        // å¿«é€Ÿç‚¹å‡» - è§¦å‘èŠ‚ç‚¹æ‰©å±•
                        if (d.type !== 'core') {
                            expandNode(d);
                        }
                    }
                    
                    if (isDragging) {
                        d3.select(this).classed('dragging', false);
                        updateDebugInfo(`âœ… æ‹–æ‹½å®Œæˆ: ${d.name}`);
                        
                        // é‡Šæ”¾å›ºå®šçº¦æŸï¼Œæ¢å¤åŠ›æ¨¡æ‹Ÿ
                        d.fx = null;
                        d.fy = null;
                        
                        if (wordCloudData.simulation) {
                            wordCloudData.simulation.alphaTarget(0);
                        }
                    }
                    
                    isDragging = false;
                });
            
            // ç»‘å®šæ‹–æ‹½è¡Œä¸ºåˆ°èŠ‚ç‚¹ç»„
            nodeGroups.call(dragBehavior);
            
            // æ·»åŠ åœ†å½¢èƒŒæ™¯
            nodeGroups.append('circle')
                .attr('class', d => `word-node ${d.type}`)
                .attr('r', getNodeRadius)
                .style('fill', d => d.type === 'fuzzy' ? getDynamicMorandiColor(d) : null) // ğŸ¯ å…³é”®ä¿®å¤ï¼šæ·»åŠ fillå±æ€§
                .style('opacity', d => d.type === 'core' ? 1 : Math.max(0.4, 0.4 + d.weight * 0.6))
                .on('click', handleNodeClick)
                .on('dblclick', handleNodeDoubleClick);
            
            // æ·»åŠ æ–‡å­— - æ™ºèƒ½é€‚åº”ç‰ˆ
            nodeGroups.append('text')
                .attr('class', 'word-text')
                .each(function(d) {
                    const radius = getNodeRadius(d);
                    const textFit = smartTextFit(d.name, radius);
                    const baseFontSize = Math.min(radius * 0.45, 13);
                    
                    d3.select(this)
                        .style('font-size', `${baseFontSize * textFit.scale}px`)
                        .text(textFit.text)
                        .append('title') // æ‚¬åœæ˜¾ç¤ºå®Œæ•´æ–‡æœ¬
                        .text(d.name);
                });
            
            // æ·»åŠ æ‰©å±•æŒ‰é’® - ä¼˜é›…é›†æˆç‰ˆ
            const expandBtns = nodeGroups.append('g')
                .attr('class', 'expand-group')
                .style('opacity', 0.85);
                
            expandBtns.append('circle')
                .attr('class', 'expand-btn')
                .attr('r', 7)
                .attr('cx', d => getNodeRadius(d) * 0.7)
                .attr('cy', d => -getNodeRadius(d) * 0.7)
                .on('click', handleExpandClick);
                
            expandBtns.append('text')
                .attr('class', 'expand-icon')
                .attr('x', d => getNodeRadius(d) * 0.7)
                .attr('y', d => -getNodeRadius(d) * 0.7)
                .text('+');
            
            // å…¥åœºåŠ¨ç”»
            nodeGroups.transition()
                .delay((d, i) => i * 50)
                .duration(800)
                .style('opacity', 1);
            
            // åŠ›æ¨¡æ‹Ÿæ›´æ–° - æ·»åŠ è¾¹ç•Œçº¦æŸ
            simulation.on('tick', () => {
                // å»é™¤çŸ©å½¢è¾¹ç•Œå¤¹é€¼ï¼Œæ”¹ç”±ç¢°æ’åŠ›ä¸è½»æŸ”å±…ä¸­åŠ›ç»´æŒå½¢æ€
                
                // æ›´æ–°ç”¨æˆ·è¿çº¿ä½ç½®
                links
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                // âœ¨ Safariå¼§å½¢è·¯å¾„æ¸²æŸ“bugä¿®å¤ï¼šä½¿ç”¨è´å¡å°”æ›²çº¿æ›¿ä»£å¼§å½¢
                semanticLinks
                    .attr('d', (d, i) => {
                        const dx = d.target.x - d.source.x;
                        const dy = d.target.y - d.source.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // è·ç¦»å¤ªè¿‘æ—¶ç›´æ¥ä½¿ç”¨ç›´çº¿ï¼Œé¿å…æ¸²æŸ“é—®é¢˜
                        if (distance < 60) {
                            return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
                        }
                        
                        // âœ¨ ä½¿ç”¨è´å¡å°”æ›²çº¿æ›¿ä»£SVGå¼§å½¢ï¼Œé¿å…Safariæ¸²æŸ“bug
                        const midX = (d.source.x + d.target.x) / 2;
                        const midY = (d.source.y + d.target.y) / 2;
                        
                        // è®¡ç®—æ§åˆ¶ç‚¹çš„åç§»ï¼Œäº¤æ›¿æ–¹å‘é¿å…é‡å 
                        const offset = 25 * (i % 2 === 0 ? 1 : -1);
                        const perpX = -dy / distance * offset;
                        const perpY = dx / distance * offset;
                        
                        const controlX = midX + perpX;
                        const controlY = midY + perpY;
                        
                        // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿ï¼Œå•ä¸€è·¯å¾„é¿å…é‡å 
                        return `M${d.source.x},${d.source.y}Q${controlX},${controlY} ${d.target.x},${d.target.y}`;
                    });
                    
                // æ›´æ–°èŠ‚ç‚¹ä½ç½®
                nodeGroups.attr('transform', d => `translate(${d.x}, ${d.y})`);
            });
            
            // ç›‘å¬æ¨¡æ‹Ÿç»“æŸï¼Œç¡®ä¿å®Œå…¨åœæ­¢
            simulation.on('end', () => {
                updateDebugInfo('ğŸ¯ å¸ƒå±€å·²ç¨³å®šï¼ŒèŠ‚ç‚¹å·²åœæ­¢ç§»åŠ¨ï¼Œå¯ä»¥å¼€å§‹ç‚¹å‡»äº¤äº’');
                console.log('ğŸ¯ åŠ›å¯¼å‘å¸ƒå±€å·²å®Œå…¨åœæ­¢');
            });
            
            // 2ç§’åå¼ºåˆ¶åœæ­¢ï¼Œç¡®ä¿ç”¨æˆ·å¯ä»¥å¿«é€Ÿäº¤äº’
            setTimeout(() => {
                simulation.stop();
                updateDebugInfo('â° å¼ºåˆ¶åœæ­¢å¸ƒå±€åŠ¨ç”»ï¼ŒèŠ‚ç‚¹ç°å·²å®Œå…¨å›ºå®š');
            }, 2000);
            
            updateStats();
            updateDebugInfo('ğŸ¨ è¯äº‘æ¸²æŸ“å®Œæˆï¼å¯ä»¥å¼€å§‹äº¤äº’æµ‹è¯•');
        }
        
        // æ™ºèƒ½æ–‡æœ¬é€‚åº”ç®—æ³• - åŸºäºä¸šç•Œæœ€ä½³å®è·µ
        function smartTextFit(text, radius) {
            // ä¸­æ–‡å­—ç¬¦å®½åº¦çº¦ç­‰äºå­—ä½“å¤§å°
            const baseTextWidth = text.length * 0.8; // ä¸­æ–‡å­—ç¬¦å®½åº¦ç³»æ•°
            const availableWidth = radius * 1.6; // åœ†å½¢å¯ç”¨å®½åº¦ï¼ˆç›´å¾„çš„80%ï¼‰
            
            // ä¼˜å…ˆç­–ç•¥ï¼šä¿æŒæ–‡æœ¬å®Œæ•´ï¼Œè°ƒæ•´å­—ä½“å¤§å°
            if (baseTextWidth <= availableWidth) {
                return { text: text, scale: 1.0 };
            }
            
            // ç­–ç•¥1ï¼šç¼©å°å­—ä½“é€‚åº”
            const scaleNeeded = availableWidth / baseTextWidth;
            if (scaleNeeded >= 0.7 && text.length <= 6) {
                return { text: text, scale: scaleNeeded };
            }
            
            // ç­–ç•¥2ï¼šæ™ºèƒ½æˆªæ–­ä¿ç•™æ ¸å¿ƒè¯­ä¹‰
            if (text.length <= 4) {
                return { text: text, scale: 0.9 };
            } else if (text.length <= 6) {
                return { text: text.substring(0, 4) + '..', scale: 0.85 };
            } else {
                // é•¿æ–‡æœ¬ï¼šä¿ç•™å…³é”®è¯æ±‡
                const core = text.substring(0, 3) + '..';
                return { text: core, scale: 0.8 };
            }
        }
        
        // è·å–èŠ‚ç‚¹åŠå¾„
        function getNodeRadius(d) {
            const baseRadius = 16;
            const maxRadius = 36;
            return d.type === 'core' ? maxRadius : baseRadius + d.weight * (maxRadius - baseRadius);
        }
        
        // èŠ‚ç‚¹ç‚¹å‡»äº‹ä»¶ - å¢å¼ºè°ƒè¯• + è¿çº¿åŠŸèƒ½
        function handleNodeClick(event, d) {
            event.stopPropagation();
            
            if (wordCloudData.connectionMode) {
                // è¿çº¿æ¨¡å¼å¤„ç†
                handleConnectionClick(d);
                return;
            }
            
            // æ™®é€šé€‰æ‹©æ¨¡å¼
            console.log('ğŸ” ç‚¹å‡»èŠ‚ç‚¹è¯¦æƒ…:', d);
            console.log('ğŸ” å½“å‰é€‰ä¸­èŠ‚ç‚¹:', wordCloudData.selectedNodes);
            
            toggleNodeSelection(d.id);
            updateNodeStyles();
            updateStats();
            updateSelectedWords();
            
            const isSelected = wordCloudData.selectedNodes.includes(d.id);
            updateDebugInfo(`ğŸ¯ ${isSelected ? 'âœ… æˆåŠŸé€‰ä¸­' : 'âŒ å–æ¶ˆé€‰ä¸­'}: ${d.name} (ç±»å‹: ${d.type}, æƒé‡: ${d.weight.toFixed(2)})`);
        }
        
        // è¿çº¿æ¨¡å¼ç‚¹å‡»å¤„ç†
        let firstConnectionNode = null;
        function handleConnectionClick(node) {
            if (!firstConnectionNode) {
                // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼Œé€‰æ‹©èµ·å§‹èŠ‚ç‚¹
                firstConnectionNode = node;
                d3.selectAll('.word-node').classed('node-connecting', false);
                d3.select(event.target).classed('node-connecting', true);
                updateDebugInfo(`ğŸ”— å·²é€‰æ‹©èµ·å§‹èŠ‚ç‚¹: ${node.name}ï¼Œè¯·ç‚¹å‡»ç›®æ ‡èŠ‚ç‚¹å»ºç«‹è¿çº¿`);
            } else if (firstConnectionNode.id === node.id) {
                // ç‚¹å‡»åŒä¸€èŠ‚ç‚¹ï¼Œå–æ¶ˆé€‰æ‹©
                firstConnectionNode = null;
                d3.selectAll('.word-node').classed('node-connecting', false);
                updateDebugInfo(`ğŸ”— å·²å–æ¶ˆè¿çº¿é€‰æ‹©`);
            } else {
                // ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼Œåˆ›å»ºè¿çº¿
                createConnection(firstConnectionNode, node);
                firstConnectionNode = null;
                d3.selectAll('.word-node').classed('node-connecting', false);
            }
        }
        
        // åˆ›å»ºè¿çº¿
        function createConnection(sourceNode, targetNode) {
            const linkId = `${sourceNode.id}-${targetNode.id}`;
            const existingLink = wordCloudData.links.find(l => 
                (l.source.id === sourceNode.id && l.target.id === targetNode.id) ||
                (l.source.id === targetNode.id && l.target.id === sourceNode.id)
            );
            
            if (existingLink) {
                updateDebugInfo(`âš ï¸ ${sourceNode.name} å’Œ ${targetNode.name} ä¹‹é—´å·²å­˜åœ¨è¿çº¿`);
                return;
            }
            
            wordCloudData.links.push({
                id: linkId,
                source: sourceNode,
                target: targetNode,
                relation: 'user_defined'
            });
            
            updateDebugInfo(`âœ… æˆåŠŸåˆ›å»ºè¿çº¿: ${sourceNode.name} â†” ${targetNode.name}`);
            renderWordCloud(); // é‡æ–°æ¸²æŸ“ä»¥æ˜¾ç¤ºæ–°è¿çº¿
        }
        
        // è¿çº¿ç‚¹å‡»äº‹ä»¶
        function handleLinkClick(event, d) {
            event.stopPropagation();
            
            const linkIndex = wordCloudData.selectedLinks.indexOf(d.id);
            if (linkIndex > -1) {
                wordCloudData.selectedLinks.splice(linkIndex, 1);
                updateDebugInfo(`âŒ å–æ¶ˆé€‰ä¸­è¿çº¿: ${d.source.name} â†” ${d.target.name}`);
            } else {
                wordCloudData.selectedLinks.push(d.id);
                updateDebugInfo(`âœ… é€‰ä¸­è¿çº¿: ${d.source.name} â†” ${d.target.name}`);
            }
            
            updateLinkStyles();
        }
        
        // åˆ‡æ¢è¿çº¿æ¨¡å¼
        function toggleConnectionMode() {
            wordCloudData.connectionMode = !wordCloudData.connectionMode;
            firstConnectionNode = null;
            
            const btn = document.getElementById('connectionBtn');
            if (wordCloudData.connectionMode) {
                btn.classList.add('connection-mode');
                btn.textContent = 'ğŸš« é€€å‡ºè¿çº¿';
                updateDebugInfo('ğŸ”— å·²è¿›å…¥è¿çº¿æ¨¡å¼ï¼Œç‚¹å‡»ä¸¤ä¸ªèŠ‚ç‚¹å»ºç«‹è¿çº¿');
            } else {
                btn.classList.remove('connection-mode');
                btn.textContent = 'ğŸ”— è¿çº¿æ¨¡å¼';
                d3.selectAll('.word-node').classed('node-connecting', false);
                updateDebugInfo('ğŸ“ å·²é€€å‡ºè¿çº¿æ¨¡å¼ï¼Œæ¢å¤æ™®é€šé€‰æ‹©æ¨¡å¼');
            }
        }
        
        // èŠ‚ç‚¹åŒå‡»äº‹ä»¶ - æ‰©å±•
        function handleNodeDoubleClick(event, d) {
            event.stopPropagation();
            expandNode(d);
        }
        
        // æ‰©å±•æŒ‰é’®ç‚¹å‡»
        function handleExpandClick(event, d) {
            event.stopPropagation();
            expandNode(d);
        }
        
        // æ‰©å±•èŠ‚ç‚¹ - å¢å¼ºè°ƒè¯•ç‰ˆ
        async function expandNode(node) {
            updateDebugInfo(`ğŸ”„ å¼€å§‹æ‰©å±•èŠ‚ç‚¹: ${node.name} (ç±»å‹: ${node.type})...`);
            console.log('ğŸ”„ æ‰©å±•èŠ‚ç‚¹è¯¦æƒ…:', node);
            
            // ğŸ¯ æ­¥éª¤1ï¼šç¡®è®¤å½“å‰èŠ‚ç‚¹çš„å…¥é“¾è·¯å¾„ï¼ˆè™šçº¿â†’å®çº¿ï¼‰
            confirmIncomingPath(node);
            
            try {
                updateDebugInfo(`ğŸ¤– æ­£åœ¨è°ƒç”¨Graphiti APIè·¯å¾„æ‰©å±•: ${node.name} (è·¯å¾„: ${(node.semanticPath || [node.name]).join('â†’')})`);
                const concepts = await getConceptNetConcepts(node, 6); // ä¼ é€’å®Œæ•´èŠ‚ç‚¹å¯¹è±¡
                
                console.log(`ğŸ“Š Graphitiè¿”å›çœŸå®æ¦‚å¿µæ•°é‡: ${concepts.length}`, concepts);
                updateDebugInfo(`ğŸ“Š GraphitiçœŸå®ç”Ÿæˆ ${concepts.length} ä¸ªæ¦‚å¿µ`);
                
                if (concepts.length === 0) {
                    updateDebugInfo(`âŒ Graphiti APIæ²¡æœ‰ä¸ºæ­¤è¯æ±‡ç”Ÿæˆæ¦‚å¿µ: ${node.name}`);
                    return;
                }
                
                const existingNames = wordCloudData.nodes.map(n => n.name);
                console.log('ğŸ” ç°æœ‰èŠ‚ç‚¹åç§°:', existingNames);
                
                // ä¸¥æ ¼å»é‡é€»è¾‘ï¼šå®Œå…¨ç¦æ­¢ä»»ä½•é‡å¤
                const newConcepts = [];
                const globalExistingWords = new Set(existingNames); // å…¨å±€å·²å­˜åœ¨çš„è¯æ±‡
                
                console.log('ğŸ“ å½“å‰å…¨å±€å·²å­˜åœ¨è¯æ±‡:', Array.from(globalExistingWords));
                
                // ä¸¥æ ¼ç­›é€‰ï¼šåªæ·»åŠ å®Œå…¨æ²¡æœ‰å‡ºç°è¿‡çš„æ¦‚å¿µ
                let addedCount = 0;
                for (const concept of concepts.slice(0, 20)) { // æ‰©å¤§æœç´¢èŒƒå›´åˆ°20ä¸ªå€™é€‰
                    if (!globalExistingWords.has(concept.word)) {
                        newConcepts.push(concept);
                        globalExistingWords.add(concept.word); // ç«‹å³åŠ å…¥å·²å­˜åœ¨é›†åˆ
                        addedCount++;
                        
                        console.log(`âœ… æ·»åŠ æ–°æ¦‚å¿µ ${addedCount}: ${concept.word} (æƒé‡: ${concept.weight.toFixed(2)})`);
                        
                        if (addedCount >= 6) break; // æœ€å¤š6ä¸ªæ–°æ¦‚å¿µ
                    } else {
                        console.log(`ğŸš« è·³è¿‡é‡å¤è¯æ±‡: ${concept.word}`);
                    }
                }
                
                console.log('ğŸ†• æ™ºèƒ½ç­›é€‰åçš„æ–°æ¦‚å¿µ:', newConcepts);
                updateDebugInfo(`ğŸ†• ä¸¥æ ¼å»é‡ç­›é€‰å¾—åˆ° ${newConcepts.length} ä¸ªå…¨æ–°æ¦‚å¿µ`);
                
                if (newConcepts.length === 0) {
                    updateDebugInfo(`âš ï¸ æ²¡æœ‰æ‰¾åˆ°æ–°çš„æ¦‚å¿µè¯æ±‡ç»™: ${node.name} (ä¸¥æ ¼å»é‡ï¼Œæœç»é‡å¤)`);
                    return;
                }
                
                // æ·»åŠ æ–°èŠ‚ç‚¹ï¼Œä½ç½®é è¿‘çˆ¶èŠ‚ç‚¹ï¼Œä½¿ç”¨æ™ºèƒ½é˜²é‡å ç®—æ³•
                newConcepts.forEach((concept, index) => {
                    // ğŸ¯ ä¼˜åŒ–è§’åº¦åˆ†å¸ƒï¼šé¿å…é‡å ï¼Œç¡®ä¿å‡åŒ€åˆ†å¸ƒ
                    const angle = (index / newConcepts.length) * 2 * Math.PI + Math.random() * 0.3;
                    
                    // ğŸ¯ æ›´ç´§å‡‘è·ç¦»ï¼šä¿æŒè§†è§‰èˆ’é€‚ä½†å‡å°‘æ•£å¸ƒ
                    const baseRadius = Math.max(65, 45 + newConcepts.length * 10); // è¿›ä¸€æ­¥ç´§å‡‘çš„åŸºç¡€è·ç¦»
                    const radius = baseRadius + Math.random() * 15; // 65-80px èŒƒå›´ï¼Œæ›´ç´§å¯†
                    
                    // ç”Ÿæˆå”¯ä¸€IDï¼šè¯æ±‡å_æ—¶é—´æˆ³_éšæœºæ•°
                    const uniqueId = `${concept.word}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                    
                    // ä½¿ç”¨GAT APIè¿”å›çš„å®Œæ•´è¯­ä¹‰è·¯å¾„
                    let currentPath;
                    if (concept.fullPath && concept.fullPath.length > 0) {
                        // ä½¿ç”¨GATè®¡ç®—çš„å®Œæ•´è·¯å¾„ï¼Œå¢åŠ å®‰å…¨æ£€æŸ¥
                        currentPath = concept.fullPath
                            .filter(p => p && (p.concept || p.name)) // âœ¨ è¿‡æ»¤ç©ºå€¼
                            .map(p => p.concept || p.name || '');
                    } else {
                        // å›é€€æ–¹æ¡ˆï¼šæ„å»ºè·¯å¾„
                        const parentPath = node.semanticPath || [node.name];
                        currentPath = [...parentPath, concept.word];
                    }
                    
                    // éªŒè¯è·¯å¾„å®Œæ•´æ€§ï¼šç¡®ä¿ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ˜¯æ ¸å¿ƒè¯
                    const rootNode = currentPath[0];
                    const isValidPath = wordCloudData.nodes.some(n => n.type === 'core' && n.name === rootNode);
                    
                    if (!isValidPath) {
                        console.warn(`âš ï¸ è·¯å¾„éªŒè¯å¤±è´¥: ${currentPath.join('â†’')} çš„æ ¹èŠ‚ç‚¹"${rootNode}"ä¸æ˜¯æ ¸å¿ƒè¯`);
                    }
                    
                    // ğŸ¯ ä½¿ç”¨æ™ºèƒ½é¿ç¢°ç®—æ³•è®¡ç®—æ— å†²çªä½ç½®
                    const avoidancePosition = calculateAvoidancePosition(
                        node, 
                        wordCloudData.nodes, 
                        angle, 
                        radius
                    );
                    
                    const newNode = {
                        id: uniqueId,
                        name: concept.word,
                        type: 'fuzzy',
                        weight: concept.weight,
                        source: 'expansion',
                        parentNode: node.id,
                        semanticPath: currentPath, // å®Œæ•´è¯­ä¹‰è·¯å¾„
                        pathDepth: currentPath.length, // è·¯å¾„æ·±åº¦
                        x: avoidancePosition.x,
                        y: avoidancePosition.y
                    };
                    
                    wordCloudData.nodes.push(newNode);
                    
                    // ç”¨æˆ·ä¸»åŠ¨æ‰©å±• - åˆ›å»ºè™šçº¿ï¼ˆæ–°AIå»ºè®®ï¼‰
                    createSemanticLink(node, newNode, 'dashed');
                });
                
                // æ˜¾ç¤ºæ¯ä¸ªæ–°èŠ‚ç‚¹çš„å®Œæ•´è·¯å¾„
                const pathInfo = newConcepts.map(c => {
                    const fullPath = [...(node.semanticPath || [node.name]), c.word];
                    return `${c.word}[${fullPath.join('â†’')}]`;
                }).join(', ');
                
                updateDebugInfo(`âœ… è·¯å¾„æ‰©å±•å®Œæˆï¼ä» ${(node.semanticPath || [node.name]).join('â†’')} æ‰©å±•äº† ${newConcepts.length} ä¸ªæ¦‚å¿µ:\n${pathInfo}`);
                
                // é‡æ–°æ¸²æŸ“
                renderWordCloud();
                updateCoreNodesList();
                
                // ğŸŒŠ è§¦å‘å±‚çº§æ·¡åŒ–æœºåˆ¶ - è®©æ—©æœŸè™šçº¿å˜æµ…
                setTimeout(() => {
                    updateSemanticLinkStyles();
                    updateAllDashedLinksOnExpansion(); // ğŸ¯ å…³é”®ï¼šè§¦å‘å±‚çº§æ·¡åŒ–
                    
                    // ğŸ¯ æ¿€æ´»èšå…‰ç¯æ•ˆåº”ï¼šèšç„¦å½“å‰æ‰©å±•è·¯å¾„
                    const expansionPath = node.semanticPath || [node.name];
                    setFocusPath(node.id, expansionPath);
                    console.log('ğŸ¯ èšå…‰ç¯æ•ˆåº”å·²æ¿€æ´»:', {nodeId: node.id, path: expansionPath});
                }, 100);
                
            } catch (error) {
                console.error('æ‰©å±•èŠ‚ç‚¹å¤±è´¥:', error);
                updateDebugInfo(`âŒ æ‰©å±•èŠ‚ç‚¹å¤±è´¥: ${error.message}`);
            }
        }
        
        // ç¡®è®¤èŠ‚ç‚¹çš„å…¥é“¾è·¯å¾„ï¼ˆè™šçº¿â†’å®çº¿ï¼‰
        function confirmIncomingPath(node) {
            let confirmedCount = 0;
            
            wordCloudData.semanticLinks.forEach(link => {
                // æ£€æŸ¥æ˜¯å¦æ˜¯è¿åˆ°å½“å‰èŠ‚ç‚¹çš„è™šçº¿
                if ((link.target.id === node.id || link.target.name === node.name) && 
                    link.type === 'dashed') {
                    link.type = 'solid';
                    confirmedCount++;
                    console.log(`âœ… è·¯å¾„ç¡®è®¤: ${link.source.name} â†’ ${link.target.name} (è™šçº¿â†’å®çº¿)`);
                    updateDebugInfo(`âœ… ç¡®è®¤è·¯å¾„: ${link.source.name} â†’ ${link.target.name}`);
                }
            });
            
            if (confirmedCount > 0) {
                // é‡æ–°æ¸²æŸ“è¿çº¿ä»¥æ˜¾ç¤ºå˜åŒ–
                updateSemanticLinks();
                updateDebugInfo(`ğŸ”— å·²ç¡®è®¤ ${confirmedCount} æ¡å…¥é“¾è·¯å¾„`);
            } else {
                updateDebugInfo(`â„¹ï¸ èŠ‚ç‚¹ ${node.name} æ²¡æœ‰éœ€è¦ç¡®è®¤çš„å…¥é“¾è·¯å¾„`);
            }
        }
        
        // æ·»åŠ æ–°çš„æ ¸å¿ƒè¯èŠ‚ç‚¹
        function addNewCoreWord() {
            const newWordInput = document.getElementById('newCoreWord');
            const newWord = newWordInput.value.trim();
            
            if (!newWord) {
                alert('è¯·è¾“å…¥æ–°çš„æ ¸å¿ƒè¯');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            const existing = wordCloudData.nodes.find(n => n.name === newWord);
            if (existing) {
                alert(`"${newWord}"å·²å­˜åœ¨äºè¯äº‘ä¸­`);
                return;
            }
            
            // æ·»åŠ æ–°çš„æ ¸å¿ƒèŠ‚ç‚¹
            const container = document.getElementById('wordcloudContainer');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // é¿å¼€ç°æœ‰èŠ‚ç‚¹çš„æ™ºèƒ½å®šä½
            const centerX = width / 2;
            const centerY = height / 2;
            let x, y;
            
            // å°è¯•æ‰¾åˆ°ä¸é‡å çš„ä½ç½®
            for (let attempt = 0; attempt < 50; attempt++) {
                const radius = 60 + attempt * 20;
                const angle = Math.random() * Math.PI * 2;
                x = centerX + radius * Math.cos(angle);
                y = centerY + radius * Math.sin(angle);
                
                // æ£€æŸ¥ä¸ç°æœ‰èŠ‚ç‚¹çš„è·ç¦»
                let validPosition = true;
                for (const node of wordCloudData.nodes) {
                    const dx = x - (node.x || 0);
                    const dy = y - (node.y || 0);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 60) { // æœ€å°é—´è·
                        validPosition = false;
                        break;
                    }
                }
                
                if (validPosition) break;
            }
            
            wordCloudData.nodes.push({
                id: newWord,
                name: newWord,
                type: 'core',
                weight: 1.0,
                source: 'user_added',
                semanticPath: [newWord], // æ–°çš„æ ¹èŠ‚ç‚¹è·¯å¾„
                pathDepth: 1,
                x: x,
                y: y
            });
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            newWordInput.value = '';
            
            updateDebugInfo(`âœ… æˆåŠŸæ·»åŠ æ–°æ ¹èŠ‚ç‚¹: ${newWord}`);
            
            // é‡æ–°æ¸²æŸ“è¯äº‘
            renderWordCloud();
            updateStats();
            updateCoreNodesList();
        }
        
        // åˆ‡æ¢èŠ‚ç‚¹é€‰æ‹©çŠ¶æ€
        function toggleNodeSelection(nodeId) {
            const index = wordCloudData.selectedNodes.indexOf(nodeId);
            if (index > -1) {
                wordCloudData.selectedNodes.splice(index, 1);
            } else {
                wordCloudData.selectedNodes.push(nodeId);
            }
        }
        
        // æ›´æ–°èŠ‚ç‚¹æ ·å¼
        function updateNodeStyles() {
            d3.selectAll('.word-node')
                .classed('selected', d => wordCloudData.selectedNodes.includes(d.id));
        }
        
        // æ›´æ–°è¿çº¿æ ·å¼
        function updateLinkStyles() {
            d3.selectAll('.word-link')
                .classed('selected', d => wordCloudData.selectedLinks.includes(d.id));
        }
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            const totalNodes = wordCloudData.nodes.length;
            const selectedNodes = wordCloudData.selectedNodes.length;
            const coreNodes = wordCloudData.nodes.filter(n => n.type === 'core').length;
            const fuzzyNodes = wordCloudData.nodes.filter(n => n.type === 'fuzzy').length;
            
            document.getElementById('totalNodes').textContent = totalNodes;
            document.getElementById('selectedNodes').textContent = selectedNodes;
            document.getElementById('coreNodes').textContent = coreNodes;
            document.getElementById('fuzzyNodes').textContent = fuzzyNodes;
        }
        
        // æ›´æ–°å·²é€‰æ‹©è¯æ±‡æ˜¾ç¤º
        function updateSelectedWords() {
            const container = document.getElementById('selectedWords');
            const tagsContainer = document.getElementById('selectedWordTags');
            
            if (wordCloudData.selectedNodes.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            tagsContainer.innerHTML = '';
            
            wordCloudData.selectedNodes.forEach(nodeId => {
                const node = wordCloudData.nodes.find(n => n.id === nodeId);
                if (node) {
                    const tag = document.createElement('span');
                    tag.className = 'selected-word-tag';
                    tag.textContent = `${node.name} (${node.type === 'core' ? 'æ ¸å¿ƒ' : 'æ¨¡ç³Š'})`;
                    tagsContainer.appendChild(tag);
                }
            });
        }
        
        // æ¸…ç©ºé€‰æ‹©
        function clearSelection() {
            wordCloudData.selectedNodes = [];
            wordCloudData.selectedLinks = [];
            updateNodeStyles();
            updateLinkStyles();
            updateStats();
            updateSelectedWords();
            updateDebugInfo('ğŸ—‘ï¸ å·²æ¸…ç©ºæ‰€æœ‰é€‰æ‹©ï¼ˆåŒ…æ‹¬èŠ‚ç‚¹å’Œè¿çº¿ï¼‰');
        }
        
        // æ›´æ–°è°ƒè¯•ä¿¡æ¯
        function updateDebugInfo(message) {
            const debugInfo = document.getElementById('debugInfo');
            const timestamp = new Date().toLocaleTimeString();
            debugInfo.textContent = `[${timestamp}] ${message}`;
            console.log(message);
        }
        
        // æ›´æ–°æ ¸å¿ƒè¯èŠ‚ç‚¹åˆ—è¡¨æ˜¾ç¤º
        function updateCoreNodesList() {
            const coreNodes = wordCloudData.nodes.filter(n => n.type === 'core');
            const listContainer = document.getElementById('coreNodesList');
            
            if (coreNodes.length === 0) {
                listContainer.innerHTML = 'ç­‰å¾…æ·»åŠ æ ¸å¿ƒè¯...';
                return;
            }
            
            const nodeList = coreNodes.map(node => {
                const childCount = wordCloudData.nodes.filter(n => 
                    n.semanticPath && n.semanticPath[0] === node.name && n.semanticPath.length > 1
                ).length;
                
                return `<span style="display: inline-block; margin: 2px 5px; padding: 4px 8px; background: #4facfe; color: white; border-radius: 12px; font-size: 12px;">
                    ${node.name} (${childCount}ä¸ªåˆ†æ”¯)
                </span>`;
            }).join('');
            
            listContainer.innerHTML = `å½“å‰æ ¹èŠ‚ç‚¹: ${nodeList}`;
        }
        
        // å¤„ç†æ–°æ ¸å¿ƒè¯è¾“å…¥çš„å›è½¦é”®
        function handleNewWordKeypress(event) {
            if (event.key === 'Enter') {
                addNewCoreWord();
            }
        }
        
        // åˆ›å»ºè¯­ä¹‰è¿çº¿
        function createSemanticLink(sourceNode, targetNode, linkType) {
            const linkId = `semantic_${sourceNode.id}_${targetNode.id}`;
            
            // é¿å…é‡å¤è¿çº¿
            if (wordCloudData.semanticLinks.find(l => l.id === linkId)) {
                return;
            }
            
            wordCloudData.semanticLinks.push({
                id: linkId,
                source: sourceNode,
                target: targetNode,
                type: linkType, // 'solid' æˆ– 'dashed'
                relation: 'semantic_path',
                linkIndex: wordCloudData.semanticLinks.length, // ç´¢å¼•ç”¨äºå¼§åº¦è®¡ç®—
                createdAt: Date.now(), // ğŸ•’ æ·»åŠ åˆ›å»ºæ—¶é—´
                sourceWeight: sourceNode.weight || 1.0, // ğŸ¯ æºèŠ‚ç‚¹æƒé‡
                targetWeight: targetNode.weight || 0.5, // ğŸ¯ ç›®æ ‡èŠ‚ç‚¹æƒé‡
                pathDepth: targetNode.pathDepth || 1 // ğŸ¯ è·¯å¾„æ·±åº¦
            });
        }
        
        // å°†èŠ‚ç‚¹è·¯å¾„ä¸Šçš„è¿çº¿å‡çº§ä¸ºå®çº¿ï¼ˆç”¨æˆ·ç¡®è®¤ï¼‰
        function upgradePathToSolid(node) {
            if (!node.parentNode) return;
            
            // æ‰¾åˆ°çˆ¶èŠ‚ç‚¹
            const parentNode = wordCloudData.nodes.find(n => n.id === node.parentNode || n.name === node.parentNode);
            if (!parentNode) return;
            
            // å‡çº§ä¸çˆ¶èŠ‚ç‚¹çš„è¿çº¿
            const linkToParent = wordCloudData.semanticLinks.find(l => 
                (l.source.id === parentNode.id && l.target.id === node.id) ||
                (l.source.id === node.id && l.target.id === parentNode.id)
            );
            
            if (linkToParent && linkToParent.type === 'dashed') {
                linkToParent.type = 'solid';
                console.log(`âœ¨ è¿çº¿å‡çº§: ${parentNode.name} â†’ ${node.name} ä»è™šçº¿å˜å®çº¿`);
            }
            
            // é€’å½’å‡çº§çˆ¶èŠ‚ç‚¹è·¯å¾„
            upgradePathToSolid(parentNode);
        }
        
        // ğŸ¨ è®¡ç®—åŸºäºæƒé‡çš„è™šçº¿é€æ˜åº¦ - ç±»ä¼¼æˆªå›¾æ•ˆæœ
        function calculateDashedLinkOpacity(link) {
            if (link.type !== 'dashed') return 0.9; // å®çº¿ä¿æŒé«˜é€æ˜åº¦
            
            const targetWeight = link.targetWeight || 0.5;
            const pathDepth = link.pathDepth || 1;
            
            // ğŸ¯ æƒé‡å› å­ï¼šæƒé‡è¶Šé«˜ï¼Œè™šçº¿è¶Šæ¸…æ™° (0.25-0.85)
            const weightFactor = Math.max(0.25, Math.min(0.85, targetWeight * 0.7 + 0.25));
            
            // ğŸ¯ å±‚çº§å› å­ï¼šè·¯å¾„è¶Šæ·±ï¼Œæ—©æœŸè¿çº¿è¶Šæµ… (0.4-1.0)
            const depthFactor = Math.max(0.4, 1.0 - (pathDepth - 1) * 0.15);
            
            // ğŸ¯ æ—¶é—´å› å­ï¼šè¶Šæ–°çš„è¿çº¿è¶Šæ¸…æ™°
            const allDashedLinks = wordCloudData.semanticLinks
                .filter(l => l.type === 'dashed' && l.createdAt)
                .sort((a, b) => b.createdAt - a.createdAt);
            const linkIndex = allDashedLinks.findIndex(l => l.id === link.id);
            const timeFactor = Math.max(0.6, 1.0 - linkIndex * 0.1);
            
            return weightFactor * depthFactor * timeFactor;
        }
        
        // ğŸ¨ è·å–è™šçº¿å±‚çº§é¢œè‰² - æˆªå›¾é£æ ¼ä¸­æ€§ç°è‰²
        function getDashedLinkColor(link) {
            if (link.type !== 'dashed') return '#007AFF'; // å®çº¿ç”¨è‹¹æœè“è‰²
            
            const targetWeight = link.targetWeight || 0.5;
            const pathDepth = link.pathDepth || 1;
            
            // ğŸ¨ åŸºäºæƒé‡å’Œå±‚çº§çš„ç°è‰²é€‰æ‹© - ç±»ä¼¼æˆªå›¾æ•ˆæœ
            if (targetWeight > 0.7) {
                return '#6B7280'; // é«˜æƒé‡ï¼šè¾ƒæ·±ç°
            } else if (targetWeight > 0.4) {
                return '#8F97A1'; // ä¸­æƒé‡ï¼šä¸­ç­‰ç°  
            } else {
                return '#A8AFB7'; // ä½æƒé‡ï¼šè¾ƒæµ…ç°
            }
        }

        // ğŸŒŠ å±‚çº§æ·¡åŒ–æœºåˆ¶ï¼šå½“æ‰©å±•æ–°èŠ‚ç‚¹æ—¶ï¼Œè®©æ—©æœŸè™šçº¿å˜æµ…
        function updateAllDashedLinksOnExpansion() {
            // ä¸ºæ‰€æœ‰è™šçº¿æ·»åŠ å¹³æ»‘è¿‡æ¸¡åŠ¨ç”»
            d3.selectAll('.semantic-link.dashed')
                .transition()
                .duration(800)
                .ease(d3.easeQuadOut)
                .style('stroke-opacity', d => calculateDashedLinkOpacity(d));
        }
        
        // æ›´æ–°è¿çº¿è§†è§‰çŠ¶æ€ - åŸºäºæƒé‡çš„æ™ºèƒ½é€æ˜åº¦ç³»ç»Ÿ
        function updateSemanticLinkStyles() {
            d3.selectAll('.semantic-link')
                .attr('class', d => `semantic-link ${d.type}`)
                .style('stroke', d => getDashedLinkColor(d))
                .style('stroke-width', d => d.type === 'solid' ? '1.8' : '2.0') // ç»Ÿä¸€è™šçº¿å®½åº¦
                .style('stroke-opacity', d => calculateDashedLinkOpacity(d)) // ğŸ¯ ä½¿ç”¨æƒé‡é€æ˜åº¦
                .style('stroke-dasharray', d => d.type === 'solid' ? 'none' : '6,3'); // æ›´ç»†è‡´çš„è™šçº¿æ ·å¼
        }
        
        // ğŸ¯ å¯¼å‡ºå¤§çº²åŠŸèƒ½
        function exportOutline() {
            if (wordCloudData.nodes.length === 0) {
                alert('è¯·å…ˆç”Ÿæˆè¯äº‘ï¼');
                return;
            }
            
            let outline = '# è¯äº‘å¤§çº²\n\n';
            
            // æ ¸å¿ƒè¯æ±‡
            const coreNodes = wordCloudData.nodes.filter(n => n.type === 'core');
            outline += '## æ ¸å¿ƒè¯æ±‡\n';
            coreNodes.forEach(node => {
                outline += `- **${node.name}**\n`;
            });
            
            // æŒ‰è¯­ä¹‰è·¯å¾„ç»„ç»‡æ‰©å±•è¯æ±‡
            outline += '\n## è¯­ä¹‰æ‰©å±•\n';
            const fuzzyNodes = wordCloudData.nodes.filter(n => n.type === 'fuzzy');
            
            // æŒ‰è·¯å¾„æ·±åº¦åˆ†ç»„
            const pathGroups = {};
            fuzzyNodes.forEach(node => {
                const rootPath = node.semanticPath?.[0] || 'æœªçŸ¥';
                if (!pathGroups[rootPath]) pathGroups[rootPath] = [];
                pathGroups[rootPath].push(node);
            });
            
            Object.keys(pathGroups).forEach(rootPath => {
                outline += `\n### ${rootPath}\n`;
                pathGroups[rootPath].forEach(node => {
                    const pathStr = node.semanticPath?.join(' â†’ ') || node.name;
                    outline += `- ${node.name} (${pathStr})\n`;
                });
            });
            
            // ä¸‹è½½æ–‡ä»¶
            const blob = new Blob([outline], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'è¯äº‘å¤§çº².md';
            a.click();
            URL.revokeObjectURL(url);
            
            updateDebugInfo('âœ… å¤§çº²å·²å¯¼å‡ºä¸º Markdown æ–‡ä»¶');
        }
        
        // ğŸ¯ å¯¼å‡ºé«˜æ¸…å›¾è°±åŠŸèƒ½
        function exportHighResImage() {
            if (wordCloudData.nodes.length === 0) {
                alert('è¯·å…ˆç”Ÿæˆè¯äº‘ï¼');
                return;
            }
            
            const svg = document.getElementById('wordCloudSvg');
            const svgData = new XMLSerializer().serializeToString(svg);
            
            // åˆ›å»ºé«˜åˆ†è¾¨ç‡Canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // è®¾ç½®é«˜åˆ†è¾¨ç‡
            const scale = 3; // 3å€åˆ†è¾¨ç‡
            canvas.width = svg.clientWidth * scale;
            canvas.height = svg.clientHeight * scale;
            
            // åˆ›å»ºå›¾åƒ
            const img = new Image();
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            img.onload = function() {
                // ç»˜åˆ¶åˆ°Canvas
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                // ä¸‹è½½é«˜æ¸…å›¾ç‰‡
                canvas.toBlob(function(blob) {
                    const downloadUrl = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = 'è¯äº‘å›¾è°±_é«˜æ¸….png';
                    a.click();
                    URL.revokeObjectURL(downloadUrl);
                }, 'image/png', 1.0);
                
                URL.revokeObjectURL(url);
                updateDebugInfo('âœ… é«˜æ¸…å›¾è°±å·²å¯¼å‡ºä¸º PNG æ–‡ä»¶');
            };
            
            img.src = url;
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåˆå§‹åŒ–
        window.onload = function() {
            updateDebugInfo('ğŸš€ æ¨¡ç³Šè¯äº‘æµ‹è¯•å™¨å·²å°±ç»ªï¼Œè¯·è¾“å…¥æ ¸å¿ƒè¯åç‚¹å‡»ç”Ÿæˆ');
        };
    </script>
</body>
</html>